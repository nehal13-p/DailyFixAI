import * as RustSdkCryptoJs from "@matrix-org/matrix-sdk-crypto-wasm";
import { OutgoingRequestProcessor } from "./OutgoingRequestProcessor.ts";
import { IHttpOpts, MatrixHttpApi } from "../http-api/index.ts";
import { ServerSideSecretStorage } from "../secret-storage.ts";
import { Logger } from "../logger.ts";
/**
 * The unstable URL prefix for dehydrated device endpoints
 */
export declare const UnstablePrefix = "/_matrix/client/unstable/org.matrix.msc3814.v1";
/**
 * Manages dehydrated devices
 *
 * We have one of these per `RustCrypto`.  It's responsible for
 *
 * * determining server support for dehydrated devices
 * * creating new dehydrated devices when requested, including periodically
 *   replacing the dehydrated device with a new one
 * * rehydrating a device when requested, and when present
 *
 * @internal
 */
export declare class DehydratedDeviceManager {
    private readonly logger;
    private readonly olmMachine;
    private readonly http;
    private readonly outgoingRequestProcessor;
    private readonly secretStorage;
    /** the secret key used for dehydrating and rehydrating */
    private key?;
    /** the ID of the interval for periodically replacing the dehydrated device */
    private intervalId?;
    constructor(logger: Logger, olmMachine: RustSdkCryptoJs.OlmMachine, http: MatrixHttpApi<IHttpOpts & {
        onlyData: true;
    }>, outgoingRequestProcessor: OutgoingRequestProcessor, secretStorage: ServerSideSecretStorage);
    /**
     * Return whether the server supports dehydrated devices.
     */
    isSupported(): Promise<boolean>;
    /**
     * Start using device dehydration.
     *
     * - Rehydrates a dehydrated device, if one is available.
     * - Creates a new dehydration key, if necessary, and stores it in Secret
     *   Storage.
     *   - If `createNewKey` is set to true, always creates a new key.
     *   - If a dehydration key is not available, creates a new one.
     * - Creates a new dehydrated device, and schedules periodically creating
     *   new dehydrated devices.
     *
     * @param createNewKey - whether to force creation of a new dehydration key.
     *   This can be used, for example, if Secret Storage is being reset.
     */
    start(createNewKey?: boolean): Promise<void>;
    /**
     * Return whether the dehydration key is stored in Secret Storage.
     */
    isKeyStored(): Promise<boolean>;
    /**
     * Reset the dehydration key.
     *
     * Creates a new key and stores it in secret storage.
     */
    resetKey(): Promise<void>;
    /**
     * Get and cache the encryption key from secret storage.
     *
     * If `create` is `true`, creates a new key if no existing key is present.
     *
     * @returns the key, if available, or `null` if no key is available
     */
    private getKey;
    /**
     * Rehydrate the dehydrated device stored on the server.
     *
     * Checks if there is a dehydrated device on the server.  If so, rehydrates
     * the device and processes the to-device events.
     *
     * Returns whether or not a dehydrated device was found.
     */
    rehydrateDeviceIfAvailable(): Promise<boolean>;
    /**
     * Creates and uploads a new dehydrated device.
     *
     * Creates and stores a new key in secret storage if none is available.
     */
    createAndUploadDehydratedDevice(): Promise<void>;
    /**
     * Schedule periodic creation of dehydrated devices.
     */
    scheduleDeviceDehydration(): Promise<void>;
    /**
     * Stop the dehydrated device manager.
     *
     * Cancels any scheduled dehydration tasks.
     */
    stop(): void;
}
//# sourceMappingURL=DehydratedDeviceManager.d.ts.map