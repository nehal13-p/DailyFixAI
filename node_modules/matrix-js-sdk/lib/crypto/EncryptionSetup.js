import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { logger } from "../logger.js";
import { MatrixEvent } from "../models/event.js";
import { createCryptoStoreCacheCallbacks } from "./CrossSigning.js";
import { IndexedDBCryptoStore } from "./store/indexeddb-crypto-store.js";
import { Method, ClientPrefix } from "../http-api/index.js";
import { ClientEvent } from "../client.js";
import { TypedEventEmitter } from "../models/typed-event-emitter.js";
/**
 * Builds an EncryptionSetupOperation by calling any of the add.. methods.
 * Once done, `buildOperation()` can be called which allows to apply to operation.
 *
 * This is used as a helper by Crypto to keep track of all the network requests
 * and other side-effects of bootstrapping, so it can be applied in one go (and retried in the future)
 * Also keeps track of all the private keys created during bootstrapping, so we don't need to prompt for them
 * more than once.
 */
export class EncryptionSetupBuilder {
  /**
   * @param accountData - pre-existing account data, will only be read, not written.
   * @param delegateCryptoCallbacks - crypto callbacks to delegate to if the key isn't in cache yet
   */
  constructor(accountData, delegateCryptoCallbacks) {
    _defineProperty(this, "accountDataClientAdapter", void 0);
    _defineProperty(this, "crossSigningCallbacks", void 0);
    _defineProperty(this, "ssssCryptoCallbacks", void 0);
    _defineProperty(this, "crossSigningKeys", void 0);
    _defineProperty(this, "keySignatures", void 0);
    _defineProperty(this, "keyBackupInfo", void 0);
    _defineProperty(this, "sessionBackupPrivateKey", void 0);
    this.accountDataClientAdapter = new AccountDataClientAdapter(accountData);
    this.crossSigningCallbacks = new CrossSigningCallbacks();
    this.ssssCryptoCallbacks = new SSSSCryptoCallbacks(delegateCryptoCallbacks);
  }

  /**
   * Adds new cross-signing public keys
   *
   * @param authUpload - Function called to await an interactive auth
   * flow when uploading device signing keys.
   * Args:
   *     A function that makes the request requiring auth. Receives
   *     the auth data as an object. Can be called multiple times, first with
   *     an empty authDict, to obtain the flows.
   * @param keys - the new keys
   */
  addCrossSigningKeys(authUpload, keys) {
    this.crossSigningKeys = {
      authUpload,
      keys
    };
  }

  /**
   * Adds the key backup info to be updated on the server
   *
   * Used either to create a new key backup, or add signatures
   * from the new MSK.
   *
   * @param keyBackupInfo - as received from/sent to the server
   */
  addSessionBackup(keyBackupInfo) {
    this.keyBackupInfo = keyBackupInfo;
  }

  /**
   * Adds the session backup private key to be updated in the local cache
   *
   * Used after fixing the format of the key
   *
   */
  addSessionBackupPrivateKeyToCache(privateKey) {
    this.sessionBackupPrivateKey = privateKey;
  }

  /**
   * Add signatures from a given user and device/x-sign key
   * Used to sign the new cross-signing key with the device key
   *
   */
  addKeySignature(userId, deviceId, signature) {
    if (!this.keySignatures) {
      this.keySignatures = {};
    }
    var userSignatures = this.keySignatures[userId] || {};
    this.keySignatures[userId] = userSignatures;
    userSignatures[deviceId] = signature;
  }
  setAccountData(type, content) {
    var _this = this;
    return _asyncToGenerator(function* () {
      yield _this.accountDataClientAdapter.setAccountData(type, content);
    })();
  }

  /**
   * builds the operation containing all the parts that have been added to the builder
   */
  buildOperation() {
    var accountData = this.accountDataClientAdapter.values;
    return new EncryptionSetupOperation(accountData, this.crossSigningKeys, this.keyBackupInfo, this.keySignatures);
  }

  /**
   * Stores the created keys locally.
   *
   * This does not yet store the operation in a way that it can be restored,
   * but that is the idea in the future.
   */
  persist(crypto) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      // store private keys in cache
      if (_this2.crossSigningKeys) {
        var cacheCallbacks = createCryptoStoreCacheCallbacks(crypto.cryptoStore, crypto.olmDevice);
        for (var type of ["master", "self_signing", "user_signing"]) {
          var _cacheCallbacks$store;
          logger.log("Cache ".concat(type, " cross-signing private key locally"));
          var privateKey = _this2.crossSigningCallbacks.privateKeys.get(type);
          yield (_cacheCallbacks$store = cacheCallbacks.storeCrossSigningKeyCache) === null || _cacheCallbacks$store === void 0 ? void 0 : _cacheCallbacks$store.call(cacheCallbacks, type, privateKey);
        }
        // store own cross-sign pubkeys as trusted
        yield crypto.cryptoStore.doTxn("readwrite", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
          crypto.cryptoStore.storeCrossSigningKeys(txn, _this2.crossSigningKeys.keys);
        });
      }
      // store session backup key in cache
      if (_this2.sessionBackupPrivateKey) {
        yield crypto.storeSessionBackupPrivateKey(_this2.sessionBackupPrivateKey);
      }
    })();
  }
}

/**
 * Can be created from EncryptionSetupBuilder, or
 * (in a follow-up PR, not implemented yet) restored from storage, to retry.
 *
 * It does not have knowledge of any private keys, unlike the builder.
 */
export class EncryptionSetupOperation {
  /**
   */
  constructor(accountData, crossSigningKeys, keyBackupInfo, keySignatures) {
    this.accountData = accountData;
    this.crossSigningKeys = crossSigningKeys;
    this.keyBackupInfo = keyBackupInfo;
    this.keySignatures = keySignatures;
  }

  /**
   * Runs the (remaining part of, in the future) operation by sending requests to the server.
   */
  apply(crypto) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      var baseApis = crypto.baseApis;
      // upload cross-signing keys
      if (_this3.crossSigningKeys) {
        var _this3$crossSigningKe, _this3$crossSigningKe2;
        var keys = {};
        for (var [name, key] of Object.entries(_this3.crossSigningKeys.keys)) {
          keys[name + "_key"] = key;
        }

        // We must only call `uploadDeviceSigningKeys` from inside this auth
        // helper to ensure we properly handle auth errors.
        yield (_this3$crossSigningKe = (_this3$crossSigningKe2 = _this3.crossSigningKeys).authUpload) === null || _this3$crossSigningKe === void 0 ? void 0 : _this3$crossSigningKe.call(_this3$crossSigningKe2, authDict => {
          return baseApis.uploadDeviceSigningKeys(authDict !== null && authDict !== void 0 ? authDict : undefined, keys);
        });

        // pass the new keys to the main instance of our own CrossSigningInfo.
        crypto.crossSigningInfo.setKeys(_this3.crossSigningKeys.keys);
      }
      // set account data
      if (_this3.accountData) {
        for (var [type, content] of _this3.accountData) {
          yield baseApis.setAccountData(type, content);
        }
      }
      // upload first cross-signing signatures with the new key
      // (e.g. signing our own device)
      if (_this3.keySignatures) {
        yield baseApis.uploadKeySignatures(_this3.keySignatures);
      }
      // need to create/update key backup info
      if (_this3.keyBackupInfo) {
        if (_this3.keyBackupInfo.version) {
          // session backup signature
          // The backup is trusted because the user provided the private key.
          // Sign the backup with the cross signing key so the key backup can
          // be trusted via cross-signing.
          yield baseApis.http.authedRequest(Method.Put, "/room_keys/version/" + _this3.keyBackupInfo.version, undefined, {
            algorithm: _this3.keyBackupInfo.algorithm,
            auth_data: _this3.keyBackupInfo.auth_data
          }, {
            prefix: ClientPrefix.V3
          });
        } else {
          // add new key backup
          yield baseApis.http.authedRequest(Method.Post, "/room_keys/version", undefined, _this3.keyBackupInfo, {
            prefix: ClientPrefix.V3
          });
        }
        // tell the backup manager to re-check the keys now that they have been (maybe) updated
        yield crypto.backupManager.checkKeyBackup();
      }
    })();
  }
}

/**
 * Catches account data set by SecretStorage during bootstrapping by
 * implementing the methods related to account data in MatrixClient
 */
class AccountDataClientAdapter extends TypedEventEmitter {
  /**
   * @param existingValues - existing account data
   */
  constructor(existingValues) {
    super();
    this.existingValues = existingValues;
    //
    _defineProperty(this, "values", new Map());
  }

  /**
   * @returns the content of the account data
   */
  getAccountDataFromServer(type) {
    return Promise.resolve(this.getAccountData(type));
  }

  /**
   * @returns the content of the account data
   */
  getAccountData(type) {
    var modifiedValue = this.values.get(type);
    if (modifiedValue) {
      return modifiedValue;
    }
    var existingValue = this.existingValues.get(type);
    if (existingValue) {
      return existingValue.getContent();
    }
    return null;
  }
  setAccountData(type, content) {
    var lastEvent = this.values.get(type);
    this.values.set(type, content);
    // ensure accountData is emitted on the next tick,
    // as SecretStorage listens for it while calling this method
    // and it seems to rely on this.
    return Promise.resolve().then(() => {
      var event = new MatrixEvent({
        type,
        content
      });
      this.emit(ClientEvent.AccountData, event, lastEvent);
      return {};
    });
  }
}

/**
 * Catches the private cross-signing keys set during bootstrapping
 * by both cache callbacks (see createCryptoStoreCacheCallbacks) as non-cache callbacks.
 * See CrossSigningInfo constructor
 */
class CrossSigningCallbacks {
  constructor() {
    _defineProperty(this, "privateKeys", new Map());
  }
  // cache callbacks
  getCrossSigningKeyCache(type, expectedPublicKey) {
    return this.getCrossSigningKey(type, expectedPublicKey);
  }
  storeCrossSigningKeyCache(type, key) {
    this.privateKeys.set(type, key);
    return Promise.resolve();
  }

  // non-cache callbacks
  getCrossSigningKey(type, expectedPubkey) {
    var _this$privateKeys$get;
    return Promise.resolve((_this$privateKeys$get = this.privateKeys.get(type)) !== null && _this$privateKeys$get !== void 0 ? _this$privateKeys$get : null);
  }
  saveCrossSigningKeys(privateKeys) {
    for (var [type, privateKey] of Object.entries(privateKeys)) {
      this.privateKeys.set(type, privateKey);
    }
  }
}

/**
 * Catches the 4S private key set during bootstrapping by implementing
 * the SecretStorage crypto callbacks
 */
class SSSSCryptoCallbacks {
  constructor(delegateCryptoCallbacks) {
    this.delegateCryptoCallbacks = delegateCryptoCallbacks;
    _defineProperty(this, "privateKeys", new Map());
  }
  getSecretStorageKey(_ref, name) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      var _this4$delegateCrypto;
      var {
        keys
      } = _ref;
      for (var keyId of Object.keys(keys)) {
        var privateKey = _this4.privateKeys.get(keyId);
        if (privateKey) {
          return [keyId, privateKey];
        }
      }
      // if we don't have the key cached yet, ask
      // for it to the general crypto callbacks and cache it
      if (_this4 !== null && _this4 !== void 0 && (_this4$delegateCrypto = _this4.delegateCryptoCallbacks) !== null && _this4$delegateCrypto !== void 0 && _this4$delegateCrypto.getSecretStorageKey) {
        var result = yield _this4.delegateCryptoCallbacks.getSecretStorageKey({
          keys
        }, name);
        if (result) {
          var [_keyId, _privateKey] = result;
          _this4.privateKeys.set(_keyId, _privateKey);
        }
        return result;
      }
      return null;
    })();
  }
  addPrivateKey(keyId, keyInfo, privKey) {
    var _this$delegateCryptoC, _this$delegateCryptoC2;
    this.privateKeys.set(keyId, privKey);
    // Also pass along to application to cache if it wishes
    (_this$delegateCryptoC = this.delegateCryptoCallbacks) === null || _this$delegateCryptoC === void 0 || (_this$delegateCryptoC2 = _this$delegateCryptoC.cacheSecretStorageKey) === null || _this$delegateCryptoC2 === void 0 || _this$delegateCryptoC2.call(_this$delegateCryptoC, keyId, keyInfo, privKey);
  }
}
//# sourceMappingURL=EncryptionSetup.js.map