{"version":3,"file":"SecretSharing.js","names":["v4","uuidv4","defer","ToDeviceMessageId","logger","olmlib","SecretSharing","constructor","baseApis","cryptoCallbacks","_defineProperty","Map","request","name","devices","requestId","makeTxnId","deferred","requests","set","cancel","reason","cancelData","action","requesting_device_id","deviceId","request_id","toDevice","device","sendToDevice","getUserId","reject","Error","requestData","info","concat","promise","onRequestReceived","event","_this","_asyncToGenerator","sender","getSender","content","getContent","onSecretRequested","secret","checkDeviceTrust","payload","type","encryptedContent","algorithm","OLM_ALGORITHM","sender_key","crypto","olmDevice","deviceCurve25519Key","ciphertext","ensureOlmSessionsForDevices","getStoredDevice","encryptMessageForDevice","contentMap","onSecretReceived","isOlmEncrypted","error","senderKeyUser","deviceList","getUserByIdentityKey","getSenderKey","log","requestControl","get","deviceInfo","getDeviceByIdentityKey","includes","deviceTrust","checkDeviceInfoTrust","isVerified","resolve"],"sources":["../../src/crypto/SecretSharing.ts"],"sourcesContent":["/*\nCopyright 2019-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport { MatrixClient } from \"../client.ts\";\nimport { ICryptoCallbacks, IEncryptedContent } from \"./index.ts\";\nimport { defer, IDeferred } from \"../utils.ts\";\nimport { ToDeviceMessageId } from \"../@types/event.ts\";\nimport { logger } from \"../logger.ts\";\nimport { MatrixEvent } from \"../models/event.ts\";\nimport * as olmlib from \"./olmlib.ts\";\n\nexport interface ISecretRequest {\n    requestId: string;\n    promise: Promise<string>;\n    cancel: (reason: string) => void;\n}\n\ninterface ISecretRequestInternal {\n    name: string;\n    devices: string[];\n    deferred: IDeferred<string>;\n}\n\nexport class SecretSharing {\n    private requests = new Map<string, ISecretRequestInternal>();\n\n    public constructor(\n        private readonly baseApis: MatrixClient,\n        private readonly cryptoCallbacks: ICryptoCallbacks,\n    ) {}\n\n    /**\n     * Request a secret from another device\n     *\n     * @param name - the name of the secret to request\n     * @param devices - the devices to request the secret from\n     */\n    public request(name: string, devices: string[]): ISecretRequest {\n        const requestId = this.baseApis.makeTxnId();\n\n        const deferred = defer<string>();\n        this.requests.set(requestId, { name, devices, deferred });\n\n        const cancel = (reason: string): void => {\n            // send cancellation event\n            const cancelData = {\n                action: \"request_cancellation\",\n                requesting_device_id: this.baseApis.deviceId,\n                request_id: requestId,\n            };\n            const toDevice: Map<string, typeof cancelData> = new Map();\n            for (const device of devices) {\n                toDevice.set(device, cancelData);\n            }\n            this.baseApis.sendToDevice(\"m.secret.request\", new Map([[this.baseApis.getUserId()!, toDevice]]));\n\n            // and reject the promise so that anyone waiting on it will be\n            // notified\n            deferred.reject(new Error(reason || \"Cancelled\"));\n        };\n\n        // send request to devices\n        const requestData = {\n            name,\n            action: \"request\",\n            requesting_device_id: this.baseApis.deviceId,\n            request_id: requestId,\n            [ToDeviceMessageId]: uuidv4(),\n        };\n        const toDevice: Map<string, typeof requestData> = new Map();\n        for (const device of devices) {\n            toDevice.set(device, requestData);\n        }\n        logger.info(`Request secret ${name} from ${devices}, id ${requestId}`);\n        this.baseApis.sendToDevice(\"m.secret.request\", new Map([[this.baseApis.getUserId()!, toDevice]]));\n\n        return {\n            requestId,\n            promise: deferred.promise,\n            cancel,\n        };\n    }\n\n    public async onRequestReceived(event: MatrixEvent): Promise<void> {\n        const sender = event.getSender();\n        const content = event.getContent();\n        if (\n            sender !== this.baseApis.getUserId() ||\n            !(content.name && content.action && content.requesting_device_id && content.request_id)\n        ) {\n            // ignore requests from anyone else, for now\n            return;\n        }\n        const deviceId = content.requesting_device_id;\n        // check if it's a cancel\n        if (content.action === \"request_cancellation\") {\n            /*\n            Looks like we intended to emit events when we got cancelations, but\n            we never put anything in the _incomingRequests object, and the request\n            itself doesn't use events anyway so if we were to wire up cancellations,\n            they probably ought to use the same callback interface. I'm leaving them\n            disabled for now while converting this file to typescript.\n            if (this._incomingRequests[deviceId]\n                && this._incomingRequests[deviceId][content.request_id]) {\n                logger.info(\n                    \"received request cancellation for secret (\" + sender +\n                    \", \" + deviceId + \", \" + content.request_id + \")\",\n                );\n                this.baseApis.emit(\"crypto.secrets.requestCancelled\", {\n                    user_id: sender,\n                    device_id: deviceId,\n                    request_id: content.request_id,\n                });\n            }\n            */\n        } else if (content.action === \"request\") {\n            if (deviceId === this.baseApis.deviceId) {\n                // no point in trying to send ourself the secret\n                return;\n            }\n\n            // check if we have the secret\n            logger.info(\"received request for secret (\" + sender + \", \" + deviceId + \", \" + content.request_id + \")\");\n            if (!this.cryptoCallbacks.onSecretRequested) {\n                return;\n            }\n            const secret = await this.cryptoCallbacks.onSecretRequested(\n                sender,\n                deviceId,\n                content.request_id,\n                content.name,\n                this.baseApis.checkDeviceTrust(sender, deviceId),\n            );\n            if (secret) {\n                logger.info(`Preparing ${content.name} secret for ${deviceId}`);\n                const payload = {\n                    type: \"m.secret.send\",\n                    content: {\n                        request_id: content.request_id,\n                        secret: secret,\n                    },\n                };\n                const encryptedContent: IEncryptedContent = {\n                    algorithm: olmlib.OLM_ALGORITHM,\n                    sender_key: this.baseApis.crypto!.olmDevice.deviceCurve25519Key!,\n                    ciphertext: {},\n                    [ToDeviceMessageId]: uuidv4(),\n                };\n                await olmlib.ensureOlmSessionsForDevices(\n                    this.baseApis.crypto!.olmDevice,\n                    this.baseApis,\n                    new Map([[sender, [this.baseApis.getStoredDevice(sender, deviceId)!]]]),\n                );\n                await olmlib.encryptMessageForDevice(\n                    encryptedContent.ciphertext,\n                    this.baseApis.getUserId()!,\n                    this.baseApis.deviceId!,\n                    this.baseApis.crypto!.olmDevice,\n                    sender,\n                    this.baseApis.getStoredDevice(sender, deviceId)!,\n                    payload,\n                );\n                const contentMap = new Map([[sender, new Map([[deviceId, encryptedContent]])]]);\n\n                logger.info(`Sending ${content.name} secret for ${deviceId}`);\n                this.baseApis.sendToDevice(\"m.room.encrypted\", contentMap);\n            } else {\n                logger.info(`Request denied for ${content.name} secret for ${deviceId}`);\n            }\n        }\n    }\n\n    public onSecretReceived(event: MatrixEvent): void {\n        if (event.getSender() !== this.baseApis.getUserId()) {\n            // we shouldn't be receiving secrets from anyone else, so ignore\n            // because someone could be trying to send us bogus data\n            return;\n        }\n\n        if (!olmlib.isOlmEncrypted(event)) {\n            logger.error(\"secret event not properly encrypted\");\n            return;\n        }\n\n        const content = event.getContent();\n\n        const senderKeyUser = this.baseApis.crypto!.deviceList.getUserByIdentityKey(\n            olmlib.OLM_ALGORITHM,\n            event.getSenderKey() || \"\",\n        );\n        if (senderKeyUser !== event.getSender()) {\n            logger.error(\"sending device does not belong to the user it claims to be from\");\n            return;\n        }\n\n        logger.log(\"got secret share for request\", content.request_id);\n        const requestControl = this.requests.get(content.request_id);\n        if (requestControl) {\n            // make sure that the device that sent it is one of the devices that\n            // we requested from\n            const deviceInfo = this.baseApis.crypto!.deviceList.getDeviceByIdentityKey(\n                olmlib.OLM_ALGORITHM,\n                event.getSenderKey()!,\n            );\n            if (!deviceInfo) {\n                logger.log(\"secret share from unknown device with key\", event.getSenderKey());\n                return;\n            }\n            if (!requestControl.devices.includes(deviceInfo.deviceId)) {\n                logger.log(\"unsolicited secret share from device\", deviceInfo.deviceId);\n                return;\n            }\n            // unsure that the sender is trusted.  In theory, this check is\n            // unnecessary since we only accept secret shares from devices that\n            // we requested from, but it doesn't hurt.\n            const deviceTrust = this.baseApis.crypto!.checkDeviceInfoTrust(event.getSender()!, deviceInfo);\n            if (!deviceTrust.isVerified()) {\n                logger.log(\"secret share from unverified device\");\n                return;\n            }\n\n            logger.log(`Successfully received secret ${requestControl.name} ` + `from ${deviceInfo.deviceId}`);\n            requestControl.deferred.resolve(content.secret);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]}