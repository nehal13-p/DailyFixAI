import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2020-2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import anotherjson from "another-json";
import { decodeBase64, encodeBase64 } from "../base64.js";
import { IndexedDBCryptoStore } from "../crypto/store/indexeddb-crypto-store.js";
import { logger } from "../logger.js";
import { Method } from "../http-api/index.js";
import decryptAESSecretStorageItem from "../utils/decryptAESSecretStorageItem.js";
import encryptAESSecretStorageItem from "../utils/encryptAESSecretStorageItem.js";
export var DEHYDRATION_ALGORITHM = "org.matrix.msc2697.v1.olm.libolm_pickle";
var oneweek = 7 * 24 * 60 * 60 * 1000;
export class DehydrationManager {
  constructor(crypto) {
    this.crypto = crypto;
    _defineProperty(this, "inProgress", false);
    _defineProperty(this, "timeoutId", void 0);
    _defineProperty(this, "key", void 0);
    _defineProperty(this, "keyInfo", void 0);
    _defineProperty(this, "deviceDisplayName", void 0);
    this.getDehydrationKeyFromCache();
  }
  getDehydrationKeyFromCache() {
    var _this = this;
    return this.crypto.cryptoStore.doTxn("readonly", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
      this.crypto.cryptoStore.getSecretStorePrivateKey(txn, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (result) {
          if (result) {
            var {
              key,
              keyInfo,
              deviceDisplayName,
              time
            } = result;
            var pickleKey = Buffer.from(_this.crypto.olmDevice.pickleKey);
            var decrypted = yield decryptAESSecretStorageItem(key, pickleKey, DEHYDRATION_ALGORITHM);
            _this.key = decodeBase64(decrypted);
            _this.keyInfo = keyInfo;
            _this.deviceDisplayName = deviceDisplayName;
            var now = Date.now();
            var delay = Math.max(1, time + oneweek - now);
            _this.timeoutId = globalThis.setTimeout(_this.dehydrateDevice.bind(_this), delay);
          }
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), "dehydration");
    });
  }

  /** set the key, and queue periodic dehydration to the server in the background */
  setKeyAndQueueDehydration(key) {
    var _arguments = arguments,
      _this2 = this;
    return _asyncToGenerator(function* () {
      var keyInfo = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};
      var deviceDisplayName = _arguments.length > 2 ? _arguments[2] : undefined;
      var matches = yield _this2.setKey(key, keyInfo, deviceDisplayName);
      if (!matches) {
        // start dehydration in the background
        _this2.dehydrateDevice();
      }
    })();
  }
  setKey(key) {
    var _arguments2 = arguments,
      _this3 = this;
    return _asyncToGenerator(function* () {
      var keyInfo = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
      var deviceDisplayName = _arguments2.length > 2 ? _arguments2[2] : undefined;
      if (!key) {
        // unsetting the key -- cancel any pending dehydration task
        if (_this3.timeoutId) {
          globalThis.clearTimeout(_this3.timeoutId);
          _this3.timeoutId = undefined;
        }
        // clear storage
        yield _this3.crypto.cryptoStore.doTxn("readwrite", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
          _this3.crypto.cryptoStore.storeSecretStorePrivateKey(txn, "dehydration", null);
        });
        _this3.key = undefined;
        _this3.keyInfo = undefined;
        return;
      }

      // Check to see if it's the same key as before.  If it's different,
      // dehydrate a new device.  If it's the same, we can keep the same
      // device.  (Assume that keyInfo and deviceDisplayName will be the
      // same if the key is the same.)
      var matches = !!_this3.key && key.length == _this3.key.length;
      for (var i = 0; matches && i < key.length; i++) {
        if (key[i] != _this3.key[i]) {
          matches = false;
        }
      }
      if (!matches) {
        _this3.key = key;
        _this3.keyInfo = keyInfo;
        _this3.deviceDisplayName = deviceDisplayName;
      }
      return matches;
    })();
  }

  /** returns the device id of the newly created dehydrated device */
  dehydrateDevice() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (_this4.inProgress) {
        logger.log("Dehydration already in progress -- not starting new dehydration");
        return;
      }
      _this4.inProgress = true;
      if (_this4.timeoutId) {
        globalThis.clearTimeout(_this4.timeoutId);
        _this4.timeoutId = undefined;
      }
      try {
        var pickleKey = Buffer.from(_this4.crypto.olmDevice.pickleKey);

        // update the crypto store with the timestamp
        var key = yield encryptAESSecretStorageItem(encodeBase64(_this4.key), pickleKey, DEHYDRATION_ALGORITHM);
        yield _this4.crypto.cryptoStore.doTxn("readwrite", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
          _this4.crypto.cryptoStore.storeSecretStorePrivateKey(txn, "dehydration", {
            keyInfo: _this4.keyInfo,
            key,
            deviceDisplayName: _this4.deviceDisplayName,
            time: Date.now()
          });
        });
        logger.log("Attempting to dehydrate device");
        logger.log("Creating account");
        // create the account and all the necessary keys
        var account = new globalThis.Olm.Account();
        account.create();
        var e2eKeys = JSON.parse(account.identity_keys());
        var maxKeys = account.max_number_of_one_time_keys();
        // FIXME: generate in small batches?
        account.generate_one_time_keys(maxKeys / 2);
        account.generate_fallback_key();
        var otks = JSON.parse(account.one_time_keys());
        var fallbacks = JSON.parse(account.fallback_key());
        account.mark_keys_as_published();

        // dehydrate the account and store it on the server
        var pickledAccount = account.pickle(new Uint8Array(_this4.key));
        var deviceData = {
          algorithm: DEHYDRATION_ALGORITHM,
          account: pickledAccount
        };
        if (_this4.keyInfo.passphrase) {
          deviceData.passphrase = _this4.keyInfo.passphrase;
        }
        logger.log("Uploading account to server");
        // eslint-disable-next-line camelcase
        var dehydrateResult = yield _this4.crypto.baseApis.http.authedRequest(Method.Put, "/dehydrated_device", undefined, {
          device_data: deviceData,
          initial_device_display_name: _this4.deviceDisplayName
        }, {
          prefix: "/_matrix/client/unstable/org.matrix.msc2697.v2"
        });

        // send the keys to the server
        var deviceId = dehydrateResult.device_id;
        logger.log("Preparing device keys", deviceId);
        var deviceKeys = {
          algorithms: _this4.crypto.supportedAlgorithms,
          device_id: deviceId,
          user_id: _this4.crypto.userId,
          keys: {
            ["ed25519:".concat(deviceId)]: e2eKeys.ed25519,
            ["curve25519:".concat(deviceId)]: e2eKeys.curve25519
          }
        };
        var deviceSignature = account.sign(anotherjson.stringify(deviceKeys));
        deviceKeys.signatures = {
          [_this4.crypto.userId]: {
            ["ed25519:".concat(deviceId)]: deviceSignature
          }
        };
        if (_this4.crypto.crossSigningInfo.getId("self_signing")) {
          yield _this4.crypto.crossSigningInfo.signObject(deviceKeys, "self_signing");
        }
        logger.log("Preparing one-time keys");
        var oneTimeKeys = {};
        for (var [keyId, _key] of Object.entries(otks.curve25519)) {
          var k = {
            key: _key
          };
          var signature = account.sign(anotherjson.stringify(k));
          k.signatures = {
            [_this4.crypto.userId]: {
              ["ed25519:".concat(deviceId)]: signature
            }
          };
          oneTimeKeys["signed_curve25519:".concat(keyId)] = k;
        }
        logger.log("Preparing fallback keys");
        var fallbackKeys = {};
        for (var [_keyId, _key2] of Object.entries(fallbacks.curve25519)) {
          var _k = {
            key: _key2,
            fallback: true
          };
          var _signature = account.sign(anotherjson.stringify(_k));
          _k.signatures = {
            [_this4.crypto.userId]: {
              ["ed25519:".concat(deviceId)]: _signature
            }
          };
          fallbackKeys["signed_curve25519:".concat(_keyId)] = _k;
        }
        logger.log("Uploading keys to server");
        yield _this4.crypto.baseApis.http.authedRequest(Method.Post, "/keys/upload/" + encodeURI(deviceId), undefined, {
          "device_keys": deviceKeys,
          "one_time_keys": oneTimeKeys,
          "org.matrix.msc2732.fallback_keys": fallbackKeys
        });
        logger.log("Done dehydrating");

        // dehydrate again in a week
        _this4.timeoutId = globalThis.setTimeout(_this4.dehydrateDevice.bind(_this4), oneweek);
        return deviceId;
      } finally {
        _this4.inProgress = false;
      }
    })();
  }
  stop() {
    if (this.timeoutId) {
      globalThis.clearTimeout(this.timeoutId);
      this.timeoutId = undefined;
    }
  }
}
//# sourceMappingURL=dehydration.js.map