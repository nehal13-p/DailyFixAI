import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2016 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Utilities common to olm encryption algorithms
 */

import anotherjson from "another-json";
import { logger } from "../logger.js";
import { EventType } from "../@types/event.js";
import { MapWithDefault } from "../utils.js";
var Algorithm = /*#__PURE__*/function (Algorithm) {
  Algorithm["Olm"] = "m.olm.v1.curve25519-aes-sha2";
  Algorithm["Megolm"] = "m.megolm.v1.aes-sha2";
  Algorithm["MegolmBackup"] = "m.megolm_backup.v1.curve25519-aes-sha2";
  return Algorithm;
}(Algorithm || {});
/**
 * matrix algorithm tag for olm
 */
export var OLM_ALGORITHM = Algorithm.Olm;

/**
 * matrix algorithm tag for megolm
 */
export var MEGOLM_ALGORITHM = Algorithm.Megolm;

/**
 * matrix algorithm tag for megolm backups
 */
export var MEGOLM_BACKUP_ALGORITHM = Algorithm.MegolmBackup;
/**
 * Encrypt an event payload for an Olm device
 *
 * @param resultsObject -  The `ciphertext` property
 *   of the m.room.encrypted event to which to add our result
 *
 * @param olmDevice - olm.js wrapper
 * @param payloadFields - fields to include in the encrypted payload
 *
 * Returns a promise which resolves (to undefined) when the payload
 *    has been encrypted into `resultsObject`
 */
export function encryptMessageForDevice(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
  return _encryptMessageForDevice.apply(this, arguments);
}
function _encryptMessageForDevice() {
  _encryptMessageForDevice = _asyncToGenerator(function* (resultsObject, ourUserId, ourDeviceId, olmDevice, recipientUserId, recipientDevice, payloadFields) {
    var deviceKey = recipientDevice.getIdentityKey();
    var sessionId = yield olmDevice.getSessionIdForDevice(deviceKey);
    if (sessionId === null) {
      // If we don't have a session for a device then
      // we can't encrypt a message for it.
      logger.log("[olmlib.encryptMessageForDevice] Unable to find Olm session for device " + "".concat(recipientUserId, ":").concat(recipientDevice.deviceId));
      return;
    }
    logger.log("[olmlib.encryptMessageForDevice] Using Olm session ".concat(sessionId, " for device ") + "".concat(recipientUserId, ":").concat(recipientDevice.deviceId));
    var payload = _objectSpread({
      sender: ourUserId,
      // TODO this appears to no longer be used whatsoever
      sender_device: ourDeviceId,
      // Include the Ed25519 key so that the recipient knows what
      // device this message came from.
      // We don't need to include the curve25519 key since the
      // recipient will already know this from the olm headers.
      // When combined with the device keys retrieved from the
      // homeserver signed by the ed25519 key this proves that
      // the curve25519 key and the ed25519 key are owned by
      // the same device.
      keys: {
        ed25519: olmDevice.deviceEd25519Key
      },
      // include the recipient device details in the payload,
      // to avoid unknown key attacks, per
      // https://github.com/vector-im/vector-web/issues/2483
      recipient: recipientUserId,
      recipient_keys: {
        ed25519: recipientDevice.getFingerprint()
      }
    }, payloadFields);

    // TODO: technically, a bunch of that stuff only needs to be included for
    // pre-key messages: after that, both sides know exactly which devices are
    // involved in the session. If we're looking to reduce data transfer in the
    // future, we could elide them for subsequent messages.

    resultsObject[deviceKey] = yield olmDevice.encryptMessage(deviceKey, sessionId, JSON.stringify(payload));
  });
  return _encryptMessageForDevice.apply(this, arguments);
}
/**
 * Get the existing olm sessions for the given devices, and the devices that
 * don't have olm sessions.
 *
 *
 *
 * @param devicesByUser - map from userid to list of devices to ensure sessions for
 *
 * @returns resolves to an array.  The first element of the array is a
 *    a map of user IDs to arrays of deviceInfo, representing the devices that
 *    don't have established olm sessions.  The second element of the array is
 *    a map from userId to deviceId to {@link OlmSessionResult}
 */
export function getExistingOlmSessions(_x8, _x9, _x10) {
  return _getExistingOlmSessions.apply(this, arguments);
}

/**
 * Try to make sure we have established olm sessions for the given devices.
 *
 * @param devicesByUser - map from userid to list of devices to ensure sessions for
 *
 * @param force - If true, establish a new session even if one
 *     already exists.
 *
 * @param otkTimeout - The timeout in milliseconds when requesting
 *     one-time keys for establishing new olm sessions.
 *
 * @param failedServers - An array to fill with remote servers that
 *     failed to respond to one-time-key requests.
 *
 * @param log - A possibly customised log
 *
 * @returns resolves once the sessions are complete, to
 *    an Object mapping from userId to deviceId to
 *    {@link OlmSessionResult}
 */
function _getExistingOlmSessions() {
  _getExistingOlmSessions = _asyncToGenerator(function* (olmDevice, baseApis, devicesByUser) {
    // map user Id → DeviceInfo[]
    var devicesWithoutSession = new MapWithDefault(() => []);
    // map user Id → device Id → IExistingOlmSession
    var sessions = new MapWithDefault(() => new Map());
    var promises = [];
    var _loop = function* _loop(userId) {
      var _loop2 = function* _loop2(deviceInfo) {
        var deviceId = deviceInfo.deviceId;
        var key = deviceInfo.getIdentityKey();
        promises.push(_asyncToGenerator(function* () {
          var sessionId = yield olmDevice.getSessionIdForDevice(key, true);
          if (sessionId === null) {
            devicesWithoutSession.getOrCreate(userId).push(deviceInfo);
          } else {
            sessions.getOrCreate(userId).set(deviceId, {
              device: deviceInfo,
              sessionId: sessionId
            });
          }
        })());
      };
      for (var deviceInfo of devices) {
        yield* _loop2(deviceInfo);
      }
    };
    for (var [userId, devices] of Object.entries(devicesByUser)) {
      yield* _loop(userId);
    }
    yield Promise.all(promises);
    return [devicesWithoutSession, sessions];
  });
  return _getExistingOlmSessions.apply(this, arguments);
}
export function ensureOlmSessionsForDevices(_x11, _x12, _x13) {
  return _ensureOlmSessionsForDevices.apply(this, arguments);
}
function _ensureOlmSessionsForDevices() {
  _ensureOlmSessionsForDevices = _asyncToGenerator(function* (olmDevice, baseApis, devicesByUser) {
    var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var otkTimeout = arguments.length > 4 ? arguments[4] : undefined;
    var failedServers = arguments.length > 5 ? arguments[5] : undefined;
    var log = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : logger;
    var devicesWithoutSession = [
      // [userId, deviceId], ...
    ];
    // map user Id → device Id → IExistingOlmSession
    var result = new Map();
    // map device key → resolve session fn
    var resolveSession = new Map();

    // Mark all sessions this task intends to update as in progress. It is
    // important to do this for all devices this task cares about in a single
    // synchronous operation, as otherwise it is possible to have deadlocks
    // where multiple tasks wait indefinitely on another task to update some set
    // of common devices.
    for (var devices of devicesByUser.values()) {
      var _loop3 = function* _loop3() {
        var key = deviceInfo.getIdentityKey();
        if (key === olmDevice.deviceCurve25519Key) {
          // We don't start sessions with ourself, so there's no need to
          // mark it in progress.
          return 1; // continue
        }
        if (!olmDevice.sessionsInProgress[key]) {
          // pre-emptively mark the session as in-progress to avoid race
          // conditions.  If we find that we already have a session, then
          // we'll resolve
          olmDevice.sessionsInProgress[key] = new Promise(resolve => {
            resolveSession.set(key, v => {
              delete olmDevice.sessionsInProgress[key];
              resolve(v);
            });
          });
        }
      };
      for (var deviceInfo of devices) {
        if (yield* _loop3()) continue;
      }
    }
    for (var [userId, _devices] of devicesByUser) {
      var resultDevices = new Map();
      result.set(userId, resultDevices);
      for (var _deviceInfo of _devices) {
        var deviceId = _deviceInfo.deviceId;
        var key = _deviceInfo.getIdentityKey();
        if (key === olmDevice.deviceCurve25519Key) {
          // We should never be trying to start a session with ourself.
          // Apart from talking to yourself being the first sign of madness,
          // olm sessions can't do this because they get confused when
          // they get a message and see that the 'other side' has started a
          // new chain when this side has an active sender chain.
          // If you see this message being logged in the wild, we should find
          // the thing that is trying to send Olm messages to itself and fix it.
          log.info("Attempted to start session with ourself! Ignoring");
          // We must fill in the section in the return value though, as callers
          // expect it to be there.
          resultDevices.set(deviceId, {
            device: _deviceInfo,
            sessionId: null
          });
          continue;
        }
        var forWhom = "for ".concat(key, " (").concat(userId, ":").concat(deviceId, ")");
        var sessionId = yield olmDevice.getSessionIdForDevice(key, !!resolveSession.get(key), log);
        var resolveSessionFn = resolveSession.get(key);
        if (sessionId !== null && resolveSessionFn) {
          // we found a session, but we had marked the session as
          // in-progress, so resolve it now, which will unmark it and
          // unblock anything that was waiting
          resolveSessionFn();
        }
        if (sessionId === null || force) {
          if (force) {
            log.info("Forcing new Olm session ".concat(forWhom));
          } else {
            log.info("Making new Olm session ".concat(forWhom));
          }
          devicesWithoutSession.push([userId, deviceId]);
        }
        resultDevices.set(deviceId, {
          device: _deviceInfo,
          sessionId: sessionId
        });
      }
    }
    if (devicesWithoutSession.length === 0) {
      return result;
    }
    var oneTimeKeyAlgorithm = "signed_curve25519";
    var res;
    var taskDetail = "one-time keys for ".concat(devicesWithoutSession.length, " devices");
    try {
      log.debug("Claiming ".concat(taskDetail));
      res = yield baseApis.claimOneTimeKeys(devicesWithoutSession, oneTimeKeyAlgorithm, otkTimeout);
      log.debug("Claimed ".concat(taskDetail));
    } catch (e) {
      for (var resolver of resolveSession.values()) {
        resolver();
      }
      log.debug("Failed to claim ".concat(taskDetail), e, devicesWithoutSession);
      throw e;
    }
    if (failedServers && "failures" in res) {
      failedServers.push(...Object.keys(res.failures));
    }
    var otkResult = res.one_time_keys || {};
    var promises = [];
    var _loop4 = function* _loop4(_userId) {
      var userRes = otkResult[_userId] || {};
      var _loop5 = function* _loop5() {
          var _result$get;
          var deviceId = _deviceInfo2.deviceId;
          var key = _deviceInfo2.getIdentityKey();
          if (key === olmDevice.deviceCurve25519Key) {
            // We've already logged about this above. Skip here too
            // otherwise we'll log saying there are no one-time keys
            // which will be confusing.
            return 0; // continue
          }
          if ((_result$get = result.get(_userId)) !== null && _result$get !== void 0 && (_result$get = _result$get.get(deviceId)) !== null && _result$get !== void 0 && _result$get.sessionId && !force) {
            // we already have a result for this device
            return 0; // continue
          }
          var deviceRes = userRes[deviceId] || {};
          var oneTimeKey = null;
          for (var keyId in deviceRes) {
            if (keyId.indexOf(oneTimeKeyAlgorithm + ":") === 0) {
              oneTimeKey = deviceRes[keyId];
            }
          }
          if (!oneTimeKey) {
            var _resolveSession$get;
            log.warn("No one-time keys (alg=".concat(oneTimeKeyAlgorithm, ") ") + "for device ".concat(_userId, ":").concat(deviceId));
            (_resolveSession$get = resolveSession.get(key)) === null || _resolveSession$get === void 0 || _resolveSession$get();
            return 0; // continue
          }
          promises.push(_verifyKeyAndStartSession(olmDevice, oneTimeKey, _userId, _deviceInfo2).then(sid => {
            var _resolveSession$get2, _result$get2;
            (_resolveSession$get2 = resolveSession.get(key)) === null || _resolveSession$get2 === void 0 || _resolveSession$get2(sid !== null && sid !== void 0 ? sid : undefined);
            var deviceInfo = (_result$get2 = result.get(_userId)) === null || _result$get2 === void 0 ? void 0 : _result$get2.get(deviceId);
            if (deviceInfo) deviceInfo.sessionId = sid;
          }, e => {
            var _resolveSession$get3;
            (_resolveSession$get3 = resolveSession.get(key)) === null || _resolveSession$get3 === void 0 || _resolveSession$get3();
            throw e;
          }));
        },
        _ret;
      for (var _deviceInfo2 of _devices2) {
        _ret = yield* _loop5();
        if (_ret === 0) continue;
      }
    };
    for (var [_userId, _devices2] of devicesByUser) {
      yield* _loop4(_userId);
    }
    taskDetail = "Olm sessions for ".concat(promises.length, " devices");
    log.debug("Starting ".concat(taskDetail));
    yield Promise.all(promises);
    log.debug("Started ".concat(taskDetail));
    return result;
  });
  return _ensureOlmSessionsForDevices.apply(this, arguments);
}
function _verifyKeyAndStartSession(_x14, _x15, _x16, _x17) {
  return _verifyKeyAndStartSession2.apply(this, arguments);
}
function _verifyKeyAndStartSession2() {
  _verifyKeyAndStartSession2 = _asyncToGenerator(function* (olmDevice, oneTimeKey, userId, deviceInfo) {
    var deviceId = deviceInfo.deviceId;
    try {
      yield verifySignature(olmDevice, oneTimeKey, userId, deviceId, deviceInfo.getFingerprint());
    } catch (e) {
      logger.error("Unable to verify signature on one-time key for device " + userId + ":" + deviceId + ":", e);
      return null;
    }
    var sid;
    try {
      sid = yield olmDevice.createOutboundSession(deviceInfo.getIdentityKey(), oneTimeKey.key);
    } catch (e) {
      // possibly a bad key
      logger.error("Error starting olm session with device " + userId + ":" + deviceId + ": " + e);
      return null;
    }
    logger.log("Started new olm sessionid " + sid + " for device " + userId + ":" + deviceId);
    return sid;
  });
  return _verifyKeyAndStartSession2.apply(this, arguments);
}
/**
 * Verify the signature on an object
 *
 * @param olmDevice - olm wrapper to use for verify op
 *
 * @param obj - object to check signature on.
 *
 * @param signingUserId -  ID of the user whose signature should be checked
 *
 * @param signingDeviceId -  ID of the device whose signature should be checked
 *
 * @param signingKey -   base64-ed ed25519 public key
 *
 * Returns a promise which resolves (to undefined) if the the signature is good,
 * or rejects with an Error if it is bad.
 */
export function verifySignature(_x18, _x19, _x20, _x21, _x22) {
  return _verifySignature.apply(this, arguments);
}

/**
 * Sign a JSON object using public key cryptography
 * @param obj - Object to sign.  The object will be modified to include
 *     the new signature
 * @param key - the signing object or the private key
 * seed
 * @param userId - The user ID who owns the signing key
 * @param pubKey - The public key (ignored if key is a seed)
 * @returns the signature for the object
 */
function _verifySignature() {
  _verifySignature = _asyncToGenerator(function* (olmDevice, obj, signingUserId, signingDeviceId, signingKey) {
    var signKeyId = "ed25519:" + signingDeviceId;
    var signatures = obj.signatures || {};
    var userSigs = signatures[signingUserId] || {};
    var signature = userSigs[signKeyId];
    if (!signature) {
      throw Error("No signature");
    }

    // prepare the canonical json: remove unsigned and signatures, and stringify with anotherjson
    var mangledObj = Object.assign({}, obj);
    if ("unsigned" in mangledObj) {
      delete mangledObj.unsigned;
    }
    delete mangledObj.signatures;
    var json = anotherjson.stringify(mangledObj);
    olmDevice.verifySignature(signingKey, json, signature);
  });
  return _verifySignature.apply(this, arguments);
}
export function pkSign(obj, key, userId, pubKey) {
  var createdKey = false;
  if (key instanceof Uint8Array) {
    var keyObj = new globalThis.Olm.PkSigning();
    pubKey = keyObj.init_with_seed(key);
    key = keyObj;
    createdKey = true;
  }
  var sigs = obj.signatures || {};
  delete obj.signatures;
  var unsigned = obj.unsigned;
  if (obj.unsigned) delete obj.unsigned;
  try {
    var mysigs = sigs[userId] || {};
    sigs[userId] = mysigs;
    return mysigs["ed25519:" + pubKey] = key.sign(anotherjson.stringify(obj));
  } finally {
    obj.signatures = sigs;
    if (unsigned) obj.unsigned = unsigned;
    if (createdKey) {
      key.free();
    }
  }
}

/**
 * Verify a signed JSON object
 * @param obj - Object to verify
 * @param pubKey - The public key to use to verify
 * @param userId - The user ID who signed the object
 */
export function pkVerify(obj, pubKey, userId) {
  var keyId = "ed25519:" + pubKey;
  if (!(obj.signatures && obj.signatures[userId] && obj.signatures[userId][keyId])) {
    throw new Error("No signature");
  }
  var signature = obj.signatures[userId][keyId];
  var util = new globalThis.Olm.Utility();
  var sigs = obj.signatures;
  delete obj.signatures;
  var unsigned = obj.unsigned;
  if (obj.unsigned) delete obj.unsigned;
  try {
    util.ed25519_verify(pubKey, anotherjson.stringify(obj), signature);
  } finally {
    obj.signatures = sigs;
    if (unsigned) obj.unsigned = unsigned;
    util.free();
  }
}

/**
 * Check that an event was encrypted using olm.
 */
export function isOlmEncrypted(event) {
  if (!event.getSenderKey()) {
    logger.error("Event has no sender key (not encrypted?)");
    return false;
  }
  if (event.getWireType() !== EventType.RoomMessageEncrypted || !["m.olm.v1.curve25519-aes-sha2"].includes(event.getWireContent().algorithm)) {
    logger.error("Event was not encrypted using an appropriate algorithm");
    return false;
  }
  return true;
}
//# sourceMappingURL=olmlib.js.map