import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
/*
Copyright 2017 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { logger } from "../../logger.js";
import { deepCompare, promiseTry, safeSet } from "../../utils.js";
import { MigrationState, SESSION_BATCH_SIZE } from "./base.js";
function encodeSessionKey(senderCurve25519Key, sessionId) {
  return encodeURIComponent(senderCurve25519Key) + "/" + encodeURIComponent(sessionId);
}
function decodeSessionKey(key) {
  var keyParts = key.split("/");
  var senderKey = decodeURIComponent(keyParts[0]);
  var sessionId = decodeURIComponent(keyParts[1]);
  return {
    senderKey,
    sessionId
  };
}

/**
 * Internal module. in-memory storage for e2e.
 */

export class MemoryCryptoStore {
  constructor() {
    _defineProperty(this, "migrationState", MigrationState.NOT_STARTED);
    _defineProperty(this, "outgoingRoomKeyRequests", []);
    _defineProperty(this, "account", null);
    _defineProperty(this, "crossSigningKeys", null);
    _defineProperty(this, "privateKeys", {});
    _defineProperty(this, "sessions", {});
    _defineProperty(this, "sessionProblems", {});
    _defineProperty(this, "notifiedErrorDevices", {});
    _defineProperty(this, "inboundGroupSessions", {});
    _defineProperty(this, "inboundGroupSessionsWithheld", {});
    // Opaque device data object
    _defineProperty(this, "deviceData", null);
    _defineProperty(this, "rooms", {});
    _defineProperty(this, "sessionsNeedingBackup", {});
    _defineProperty(this, "sharedHistoryInboundGroupSessions", {});
    _defineProperty(this, "parkedSharedHistory", new Map());
  }
  // keyed by room ID

  /**
   * Returns true if this CryptoStore has ever been initialised (ie, it might contain data).
   *
   * Implementation of {@link CryptoStore.containsData}.
   *
   * @internal
   */
  containsData() {
    var _this = this;
    return _asyncToGenerator(function* () {
      // If it contains anything, it should contain an account.
      return _this.account !== null;
    })();
  }

  /**
   * Ensure the database exists and is up-to-date.
   *
   * This must be called before the store can be used.
   *
   * @returns resolves to the store.
   */
  startup() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      // No startup work to do for the memory store.
      return _this2;
    })();
  }

  /**
   * Delete all data from this store.
   *
   * @returns Promise which resolves when the store has been cleared.
   */
  deleteAllData() {
    return Promise.resolve();
  }

  /**
   * Get data on how much of the libolm to Rust Crypto migration has been done.
   *
   * Implementation of {@link CryptoStore.getMigrationState}.
   *
   * @internal
   */
  getMigrationState() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      return _this3.migrationState;
    })();
  }

  /**
   * Set data on how much of the libolm to Rust Crypto migration has been done.
   *
   * Implementation of {@link CryptoStore.setMigrationState}.
   *
   * @internal
   */
  setMigrationState(migrationState) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      _this4.migrationState = migrationState;
    })();
  }

  /**
   * Look for an existing outgoing room key request, and if none is found,
   * add a new one
   *
   *
   * @returns resolves to
   *    {@link OutgoingRoomKeyRequest}: either the
   *    same instance as passed in, or the existing one.
   */
  getOrAddOutgoingRoomKeyRequest(request) {
    var requestBody = request.requestBody;
    return promiseTry(() => {
      // first see if we already have an entry for this request.
      var existing = this._getOutgoingRoomKeyRequest(requestBody);
      if (existing) {
        // this entry matches the request - return it.
        logger.log("already have key request outstanding for " + "".concat(requestBody.room_id, " / ").concat(requestBody.session_id, ": ") + "not sending another");
        return existing;
      }

      // we got to the end of the list without finding a match
      // - add the new request.
      logger.log("enqueueing key request for ".concat(requestBody.room_id, " / ") + requestBody.session_id);
      this.outgoingRoomKeyRequests.push(request);
      return request;
    });
  }

  /**
   * Look for an existing room key request
   *
   * @param requestBody - existing request to look for
   *
   * @returns resolves to the matching
   *    {@link OutgoingRoomKeyRequest}, or null if
   *    not found
   */
  getOutgoingRoomKeyRequest(requestBody) {
    return Promise.resolve(this._getOutgoingRoomKeyRequest(requestBody));
  }

  /**
   * Looks for existing room key request, and returns the result synchronously.
   *
   * @internal
   *
   * @param requestBody - existing request to look for
   *
   * @returns
   *    the matching request, or null if not found
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _getOutgoingRoomKeyRequest(requestBody) {
    for (var existing of this.outgoingRoomKeyRequests) {
      if (deepCompare(existing.requestBody, requestBody)) {
        return existing;
      }
    }
    return null;
  }

  /**
   * Look for room key requests by state
   *
   * @param wantedStates - list of acceptable states
   *
   * @returns resolves to the a
   *    {@link OutgoingRoomKeyRequest}, or null if
   *    there are no pending requests in those states
   */
  getOutgoingRoomKeyRequestByState(wantedStates) {
    for (var req of this.outgoingRoomKeyRequests) {
      for (var state of wantedStates) {
        if (req.state === state) {
          return Promise.resolve(req);
        }
      }
    }
    return Promise.resolve(null);
  }

  /**
   *
   * @returns All OutgoingRoomKeyRequests in state
   */
  getAllOutgoingRoomKeyRequestsByState(wantedState) {
    return Promise.resolve(this.outgoingRoomKeyRequests.filter(r => r.state == wantedState));
  }
  getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates) {
    var results = [];
    for (var req of this.outgoingRoomKeyRequests) {
      for (var state of wantedStates) {
        if (req.state === state && req.recipients.some(recipient => recipient.userId === userId && recipient.deviceId === deviceId)) {
          results.push(req);
        }
      }
    }
    return Promise.resolve(results);
  }

  /**
   * Look for an existing room key request by id and state, and update it if
   * found
   *
   * @param requestId -      ID of request to update
   * @param expectedState -  state we expect to find the request in
   * @param updates -        name/value map of updates to apply
   *
   * @returns resolves to
   *    {@link OutgoingRoomKeyRequest}
   *    updated request, or null if no matching row was found
   */
  updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {
    for (var req of this.outgoingRoomKeyRequests) {
      if (req.requestId !== requestId) {
        continue;
      }
      if (req.state !== expectedState) {
        logger.warn("Cannot update room key request from ".concat(expectedState, " ") + "as it was already updated to ".concat(req.state));
        return Promise.resolve(null);
      }
      Object.assign(req, updates);
      return Promise.resolve(req);
    }
    return Promise.resolve(null);
  }

  /**
   * Look for an existing room key request by id and state, and delete it if
   * found
   *
   * @param requestId -      ID of request to update
   * @param expectedState -  state we expect to find the request in
   *
   * @returns resolves once the operation is completed
   */
  deleteOutgoingRoomKeyRequest(requestId, expectedState) {
    for (var i = 0; i < this.outgoingRoomKeyRequests.length; i++) {
      var req = this.outgoingRoomKeyRequests[i];
      if (req.requestId !== requestId) {
        continue;
      }
      if (req.state != expectedState) {
        logger.warn("Cannot delete room key request in state ".concat(req.state, " ") + "(expected ".concat(expectedState, ")"));
        return Promise.resolve(null);
      }
      this.outgoingRoomKeyRequests.splice(i, 1);
      return Promise.resolve(req);
    }
    return Promise.resolve(null);
  }

  // Olm Account

  getAccount(txn, func) {
    func(this.account);
  }
  storeAccount(txn, accountPickle) {
    this.account = accountPickle;
  }
  getCrossSigningKeys(txn, func) {
    func(this.crossSigningKeys);
  }
  getSecretStorePrivateKey(txn, func, type) {
    var result = this.privateKeys[type];
    func(result || null);
  }
  storeCrossSigningKeys(txn, keys) {
    this.crossSigningKeys = keys;
  }
  storeSecretStorePrivateKey(txn, type, key) {
    this.privateKeys[type] = key;
  }

  // Olm Sessions

  countEndToEndSessions(txn, func) {
    var count = 0;
    for (var deviceSessions of Object.values(this.sessions)) {
      count += Object.keys(deviceSessions).length;
    }
    func(count);
  }
  getEndToEndSession(deviceKey, sessionId, txn, func) {
    var deviceSessions = this.sessions[deviceKey] || {};
    func(deviceSessions[sessionId] || null);
  }
  getEndToEndSessions(deviceKey, txn, func) {
    func(this.sessions[deviceKey] || {});
  }
  getAllEndToEndSessions(txn, func) {
    Object.entries(this.sessions).forEach(_ref => {
      var [deviceKey, deviceSessions] = _ref;
      Object.entries(deviceSessions).forEach(_ref2 => {
        var [sessionId, session] = _ref2;
        func(_objectSpread(_objectSpread({}, session), {}, {
          deviceKey,
          sessionId
        }));
      });
    });
  }
  storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
    var deviceSessions = this.sessions[deviceKey];
    if (deviceSessions === undefined) {
      deviceSessions = {};
      this.sessions[deviceKey] = deviceSessions;
    }
    safeSet(deviceSessions, sessionId, sessionInfo);
  }
  storeEndToEndSessionProblem(deviceKey, type, fixed) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      var problems = _this5.sessionProblems[deviceKey] = _this5.sessionProblems[deviceKey] || [];
      problems.push({
        type,
        fixed,
        time: Date.now()
      });
      problems.sort((a, b) => {
        return a.time - b.time;
      });
    })();
  }
  getEndToEndSessionProblem(deviceKey, timestamp) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      var problems = _this6.sessionProblems[deviceKey] || [];
      if (!problems.length) {
        return null;
      }
      var lastProblem = problems[problems.length - 1];
      for (var problem of problems) {
        if (problem.time > timestamp) {
          return Object.assign({}, problem, {
            fixed: lastProblem.fixed
          });
        }
      }
      if (lastProblem.fixed) {
        return null;
      } else {
        return lastProblem;
      }
    })();
  }
  filterOutNotifiedErrorDevices(devices) {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      var notifiedErrorDevices = _this7.notifiedErrorDevices;
      var ret = [];
      for (var device of devices) {
        var {
          userId,
          deviceInfo
        } = device;
        if (userId in notifiedErrorDevices) {
          if (!(deviceInfo.deviceId in notifiedErrorDevices[userId])) {
            ret.push(device);
            safeSet(notifiedErrorDevices[userId], deviceInfo.deviceId, true);
          }
        } else {
          ret.push(device);
          safeSet(notifiedErrorDevices, userId, {
            [deviceInfo.deviceId]: true
          });
        }
      }
      return ret;
    })();
  }

  /**
   * Fetch a batch of Olm sessions from the database.
   *
   * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.
   *
   * @internal
   */
  getEndToEndSessionsBatch() {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      var result = [];
      for (var deviceSessions of Object.values(_this8.sessions)) {
        for (var session of Object.values(deviceSessions)) {
          result.push(session);
          if (result.length >= SESSION_BATCH_SIZE) {
            return result;
          }
        }
      }
      if (result.length === 0) {
        // No sessions left.
        return null;
      }

      // There are fewer sessions than the batch size; return the final batch of sessions.
      return result;
    })();
  }

  /**
   * Delete a batch of Olm sessions from the database.
   *
   * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.
   *
   * @internal
   */
  deleteEndToEndSessionsBatch(sessions) {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      for (var {
        deviceKey,
        sessionId
      } of sessions) {
        var deviceSessions = _this9.sessions[deviceKey] || {};
        delete deviceSessions[sessionId];
        if (Object.keys(deviceSessions).length === 0) {
          // No more sessions for this device.
          delete _this9.sessions[deviceKey];
        }
      }
    })();
  }

  // Inbound Group Sessions

  getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
    var k = encodeSessionKey(senderCurve25519Key, sessionId);
    func(this.inboundGroupSessions[k] || null, this.inboundGroupSessionsWithheld[k] || null);
  }
  getAllEndToEndInboundGroupSessions(txn, func) {
    for (var key of Object.keys(this.inboundGroupSessions)) {
      func(_objectSpread(_objectSpread({}, decodeSessionKey(key)), {}, {
        sessionData: this.inboundGroupSessions[key]
      }));
    }
    func(null);
  }
  addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
    var k = encodeSessionKey(senderCurve25519Key, sessionId);
    if (this.inboundGroupSessions[k] === undefined) {
      this.inboundGroupSessions[k] = sessionData;
    }
  }
  storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
    var k = encodeSessionKey(senderCurve25519Key, sessionId);
    this.inboundGroupSessions[k] = sessionData;
  }
  storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
    var k = encodeSessionKey(senderCurve25519Key, sessionId);
    this.inboundGroupSessionsWithheld[k] = sessionData;
  }

  /**
   * Count the number of Megolm sessions in the database.
   *
   * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.
   *
   * @internal
   */
  countEndToEndInboundGroupSessions() {
    var _this10 = this;
    return _asyncToGenerator(function* () {
      return Object.keys(_this10.inboundGroupSessions).length;
    })();
  }

  /**
   * Fetch a batch of Megolm sessions from the database.
   *
   * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.
   *
   * @internal
   */
  getEndToEndInboundGroupSessionsBatch() {
    var _this11 = this;
    return _asyncToGenerator(function* () {
      var result = [];
      for (var [key, session] of Object.entries(_this11.inboundGroupSessions)) {
        result.push(_objectSpread(_objectSpread({}, decodeSessionKey(key)), {}, {
          sessionData: session,
          needsBackup: key in _this11.sessionsNeedingBackup
        }));
        if (result.length >= SESSION_BATCH_SIZE) {
          return result;
        }
      }
      if (result.length === 0) {
        // No sessions left.
        return null;
      }

      // There are fewer sessions than the batch size; return the final batch of sessions.
      return result;
    })();
  }

  /**
   * Delete a batch of Megolm sessions from the database.
   *
   * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.
   *
   * @internal
   */
  deleteEndToEndInboundGroupSessionsBatch(sessions) {
    var _this12 = this;
    return _asyncToGenerator(function* () {
      for (var {
        senderKey,
        sessionId
      } of sessions) {
        var k = encodeSessionKey(senderKey, sessionId);
        delete _this12.inboundGroupSessions[k];
      }
    })();
  }

  // Device Data

  getEndToEndDeviceData(txn, func) {
    func(this.deviceData);
  }
  storeEndToEndDeviceData(deviceData, txn) {
    this.deviceData = deviceData;
  }

  // E2E rooms

  storeEndToEndRoom(roomId, roomInfo, txn) {
    this.rooms[roomId] = roomInfo;
  }
  getEndToEndRooms(txn, func) {
    func(this.rooms);
  }
  getSessionsNeedingBackup(limit) {
    var sessions = [];
    for (var session in this.sessionsNeedingBackup) {
      if (this.inboundGroupSessions[session]) {
        sessions.push(_objectSpread(_objectSpread({}, decodeSessionKey(session)), {}, {
          sessionData: this.inboundGroupSessions[session]
        }));
        if (limit && session.length >= limit) {
          break;
        }
      }
    }
    return Promise.resolve(sessions);
  }
  countSessionsNeedingBackup() {
    return Promise.resolve(Object.keys(this.sessionsNeedingBackup).length);
  }
  unmarkSessionsNeedingBackup(sessions) {
    for (var session of sessions) {
      var sessionKey = encodeSessionKey(session.senderKey, session.sessionId);
      delete this.sessionsNeedingBackup[sessionKey];
    }
    return Promise.resolve();
  }
  markSessionsNeedingBackup(sessions) {
    for (var session of sessions) {
      var sessionKey = encodeSessionKey(session.senderKey, session.sessionId);
      this.sessionsNeedingBackup[sessionKey] = true;
    }
    return Promise.resolve();
  }
  addSharedHistoryInboundGroupSession(roomId, senderKey, sessionId) {
    var sessions = this.sharedHistoryInboundGroupSessions[roomId] || [];
    sessions.push([senderKey, sessionId]);
    this.sharedHistoryInboundGroupSessions[roomId] = sessions;
  }
  getSharedHistoryInboundGroupSessions(roomId) {
    return Promise.resolve(this.sharedHistoryInboundGroupSessions[roomId] || []);
  }
  addParkedSharedHistory(roomId, parkedData) {
    var _this$parkedSharedHis;
    var parked = (_this$parkedSharedHis = this.parkedSharedHistory.get(roomId)) !== null && _this$parkedSharedHis !== void 0 ? _this$parkedSharedHis : [];
    parked.push(parkedData);
    this.parkedSharedHistory.set(roomId, parked);
  }
  takeParkedSharedHistory(roomId) {
    var _this$parkedSharedHis2;
    var parked = (_this$parkedSharedHis2 = this.parkedSharedHistory.get(roomId)) !== null && _this$parkedSharedHis2 !== void 0 ? _this$parkedSharedHis2 : [];
    this.parkedSharedHistory.delete(roomId);
    return Promise.resolve(parked);
  }

  // Session key backups

  doTxn(mode, stores, func) {
    return Promise.resolve(func(null));
  }
}
//# sourceMappingURL=memory-crypto-store.js.map