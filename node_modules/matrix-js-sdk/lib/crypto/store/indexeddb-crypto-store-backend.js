import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2017 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { logger } from "../../logger.js";
import { deepCompare } from "../../utils.js";
import { MigrationState, SESSION_BATCH_SIZE, ACCOUNT_OBJECT_KEY_MIGRATION_STATE } from "./base.js";
import { IndexedDBCryptoStore } from "./indexeddb-crypto-store.js";
var PROFILE_TRANSACTIONS = false;

/**
 * Implementation of a CryptoStore which is backed by an existing
 * IndexedDB connection. Generally you want IndexedDBCryptoStore
 * which connects to the database and defers to one of these.
 *
 * @internal
 */
export class Backend {
  /**
   */
  constructor(db) {
    this.db = db;
    _defineProperty(this, "nextTxnId", 0);
    // make sure we close the db on `onversionchange` - otherwise
    // attempts to delete the database will block (and subsequent
    // attempts to re-create it will also block).
    db.onversionchange = () => {
      logger.log("versionchange for indexeddb ".concat(this.db.name, ": closing"));
      db.close();
    };
  }
  containsData() {
    return _asyncToGenerator(function* () {
      throw Error("Not implemented for Backend");
    })();
  }
  startup() {
    var _this = this;
    return _asyncToGenerator(function* () {
      // No work to do, as the startup is done by the caller (e.g IndexedDBCryptoStore)
      // by passing us a ready IDBDatabase instance
      return _this;
    })();
  }
  deleteAllData() {
    return _asyncToGenerator(function* () {
      throw Error("This is not implemented, call IDBFactory::deleteDatabase(dbName) instead.");
    })();
  }

  /**
   * Get data on how much of the libolm to Rust Crypto migration has been done.
   *
   * Implementation of {@link CryptoStore.getMigrationState}.
   */
  getMigrationState() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var migrationState = MigrationState.NOT_STARTED;
      yield _this2.doTxn("readonly", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
        var objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);
        var getReq = objectStore.get(ACCOUNT_OBJECT_KEY_MIGRATION_STATE);
        getReq.onsuccess = () => {
          var _getReq$result;
          migrationState = (_getReq$result = getReq.result) !== null && _getReq$result !== void 0 ? _getReq$result : MigrationState.NOT_STARTED;
        };
      });
      return migrationState;
    })();
  }

  /**
   * Set data on how much of the libolm to Rust Crypto migration has been done.
   *
   * Implementation of {@link CryptoStore.setMigrationState}.
   */
  setMigrationState(migrationState) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      yield _this3.doTxn("readwrite", [IndexedDBCryptoStore.STORE_ACCOUNT], txn => {
        var objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_ACCOUNT);
        objectStore.put(migrationState, ACCOUNT_OBJECT_KEY_MIGRATION_STATE);
      });
    })();
  }

  /**
   * Look for an existing outgoing room key request, and if none is found,
   * add a new one
   *
   *
   * @returns resolves to
   *    {@link OutgoingRoomKeyRequest}: either the
   *    same instance as passed in, or the existing one.
   */
  getOrAddOutgoingRoomKeyRequest(request) {
    var requestBody = request.requestBody;
    return new Promise((resolve, reject) => {
      var txn = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
      txn.onerror = reject;

      // first see if we already have an entry for this request.
      this._getOutgoingRoomKeyRequest(txn, requestBody, existing => {
        if (existing) {
          // this entry matches the request - return it.
          logger.log("already have key request outstanding for " + "".concat(requestBody.room_id, " / ").concat(requestBody.session_id, ": ") + "not sending another");
          resolve(existing);
          return;
        }

        // we got to the end of the list without finding a match
        // - add the new request.
        logger.log("enqueueing key request for ".concat(requestBody.room_id, " / ") + requestBody.session_id);
        txn.oncomplete = () => {
          resolve(request);
        };
        var store = txn.objectStore("outgoingRoomKeyRequests");
        store.add(request);
      });
    });
  }

  /**
   * Look for an existing room key request
   *
   * @param requestBody - existing request to look for
   *
   * @returns resolves to the matching
   *    {@link OutgoingRoomKeyRequest}, or null if
   *    not found
   */
  getOutgoingRoomKeyRequest(requestBody) {
    return new Promise((resolve, reject) => {
      var txn = this.db.transaction("outgoingRoomKeyRequests", "readonly");
      txn.onerror = reject;
      this._getOutgoingRoomKeyRequest(txn, requestBody, existing => {
        resolve(existing);
      });
    });
  }

  /**
   * look for an existing room key request in the db
   *
   * @internal
   * @param txn -  database transaction
   * @param requestBody - existing request to look for
   * @param callback -  function to call with the results of the
   *    search. Either passed a matching
   *    {@link OutgoingRoomKeyRequest}, or null if
   *    not found.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _getOutgoingRoomKeyRequest(txn, requestBody, callback) {
    var store = txn.objectStore("outgoingRoomKeyRequests");
    var idx = store.index("session");
    var cursorReq = idx.openCursor([requestBody.room_id, requestBody.session_id]);
    cursorReq.onsuccess = () => {
      var cursor = cursorReq.result;
      if (!cursor) {
        // no match found
        callback(null);
        return;
      }
      var existing = cursor.value;
      if (deepCompare(existing.requestBody, requestBody)) {
        // got a match
        callback(existing);
        return;
      }

      // look at the next entry in the index
      cursor.continue();
    };
  }

  /**
   * Look for room key requests by state
   *
   * @param wantedStates - list of acceptable states
   *
   * @returns resolves to the a
   *    {@link OutgoingRoomKeyRequest}, or null if
   *    there are no pending requests in those states. If there are multiple
   *    requests in those states, an arbitrary one is chosen.
   */
  getOutgoingRoomKeyRequestByState(wantedStates) {
    if (wantedStates.length === 0) {
      return Promise.resolve(null);
    }

    // this is a bit tortuous because we need to make sure we do the lookup
    // in a single transaction, to avoid having a race with the insertion
    // code.

    // index into the wantedStates array
    var stateIndex = 0;
    var result;
    function onsuccess() {
      var cursor = this.result;
      if (cursor) {
        // got a match
        result = cursor.value;
        return;
      }

      // try the next state in the list
      stateIndex++;
      if (stateIndex >= wantedStates.length) {
        // no matches
        return;
      }
      var wantedState = wantedStates[stateIndex];
      var cursorReq = this.source.openCursor(wantedState);
      cursorReq.onsuccess = onsuccess;
    }
    var txn = this.db.transaction("outgoingRoomKeyRequests", "readonly");
    var store = txn.objectStore("outgoingRoomKeyRequests");
    var wantedState = wantedStates[stateIndex];
    var cursorReq = store.index("state").openCursor(wantedState);
    cursorReq.onsuccess = onsuccess;
    return promiseifyTxn(txn).then(() => result);
  }

  /**
   *
   * @returns All elements in a given state
   */
  getAllOutgoingRoomKeyRequestsByState(wantedState) {
    return new Promise((resolve, reject) => {
      var txn = this.db.transaction("outgoingRoomKeyRequests", "readonly");
      var store = txn.objectStore("outgoingRoomKeyRequests");
      var index = store.index("state");
      var request = index.getAll(wantedState);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  getOutgoingRoomKeyRequestsByTarget(userId, deviceId, wantedStates) {
    var stateIndex = 0;
    var results = [];
    function onsuccess() {
      var cursor = this.result;
      if (cursor) {
        var keyReq = cursor.value;
        if (keyReq.recipients.some(recipient => recipient.userId === userId && recipient.deviceId === deviceId)) {
          results.push(keyReq);
        }
        cursor.continue();
      } else {
        // try the next state in the list
        stateIndex++;
        if (stateIndex >= wantedStates.length) {
          // no matches
          return;
        }
        var _wantedState = wantedStates[stateIndex];
        var _cursorReq = this.source.openCursor(_wantedState);
        _cursorReq.onsuccess = onsuccess;
      }
    }
    var txn = this.db.transaction("outgoingRoomKeyRequests", "readonly");
    var store = txn.objectStore("outgoingRoomKeyRequests");
    var wantedState = wantedStates[stateIndex];
    var cursorReq = store.index("state").openCursor(wantedState);
    cursorReq.onsuccess = onsuccess;
    return promiseifyTxn(txn).then(() => results);
  }

  /**
   * Look for an existing room key request by id and state, and update it if
   * found
   *
   * @param requestId -      ID of request to update
   * @param expectedState -  state we expect to find the request in
   * @param updates -        name/value map of updates to apply
   *
   * @returns resolves to
   *    {@link OutgoingRoomKeyRequest}
   *    updated request, or null if no matching row was found
   */
  updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {
    var result = null;
    function onsuccess() {
      var cursor = this.result;
      if (!cursor) {
        return;
      }
      var data = cursor.value;
      if (data.state != expectedState) {
        logger.warn("Cannot update room key request from ".concat(expectedState, " ") + "as it was already updated to ".concat(data.state));
        return;
      }
      Object.assign(data, updates);
      cursor.update(data);
      result = data;
    }
    var txn = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
    var cursorReq = txn.objectStore("outgoingRoomKeyRequests").openCursor(requestId);
    cursorReq.onsuccess = onsuccess;
    return promiseifyTxn(txn).then(() => result);
  }

  /**
   * Look for an existing room key request by id and state, and delete it if
   * found
   *
   * @param requestId -      ID of request to update
   * @param expectedState -  state we expect to find the request in
   *
   * @returns resolves once the operation is completed
   */
  deleteOutgoingRoomKeyRequest(requestId, expectedState) {
    var txn = this.db.transaction("outgoingRoomKeyRequests", "readwrite");
    var cursorReq = txn.objectStore("outgoingRoomKeyRequests").openCursor(requestId);
    cursorReq.onsuccess = () => {
      var cursor = cursorReq.result;
      if (!cursor) {
        return;
      }
      var data = cursor.value;
      if (data.state != expectedState) {
        logger.warn("Cannot delete room key request in state ".concat(data.state, " ") + "(expected ".concat(expectedState, ")"));
        return;
      }
      cursor.delete();
    };
    return promiseifyTxn(txn);
  }

  // Olm Account

  getAccount(txn, func) {
    var objectStore = txn.objectStore("account");
    var getReq = objectStore.get("-");
    getReq.onsuccess = function () {
      try {
        func(getReq.result || null);
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  storeAccount(txn, accountPickle) {
    var objectStore = txn.objectStore("account");
    objectStore.put(accountPickle, "-");
  }
  getCrossSigningKeys(txn, func) {
    var objectStore = txn.objectStore("account");
    var getReq = objectStore.get("crossSigningKeys");
    getReq.onsuccess = function () {
      try {
        func(getReq.result || null);
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  getSecretStorePrivateKey(txn, func, type) {
    var objectStore = txn.objectStore("account");
    var getReq = objectStore.get("ssss_cache:".concat(type));
    getReq.onsuccess = function () {
      try {
        func(getReq.result || null);
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  storeCrossSigningKeys(txn, keys) {
    var objectStore = txn.objectStore("account");
    objectStore.put(keys, "crossSigningKeys");
  }
  storeSecretStorePrivateKey(txn, type, key) {
    var objectStore = txn.objectStore("account");
    objectStore.put(key, "ssss_cache:".concat(type));
  }

  // Olm Sessions

  countEndToEndSessions(txn, func) {
    var objectStore = txn.objectStore("sessions");
    var countReq = objectStore.count();
    countReq.onsuccess = function () {
      try {
        func(countReq.result);
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  getEndToEndSessions(deviceKey, txn, func) {
    var objectStore = txn.objectStore("sessions");
    var idx = objectStore.index("deviceKey");
    var getReq = idx.openCursor(deviceKey);
    var results = {};
    getReq.onsuccess = function () {
      var cursor = getReq.result;
      if (cursor) {
        results[cursor.value.sessionId] = {
          session: cursor.value.session,
          lastReceivedMessageTs: cursor.value.lastReceivedMessageTs
        };
        cursor.continue();
      } else {
        try {
          func(results);
        } catch (e) {
          abortWithException(txn, e);
        }
      }
    };
  }
  getEndToEndSession(deviceKey, sessionId, txn, func) {
    var objectStore = txn.objectStore("sessions");
    var getReq = objectStore.get([deviceKey, sessionId]);
    getReq.onsuccess = function () {
      try {
        if (getReq.result) {
          func({
            session: getReq.result.session,
            lastReceivedMessageTs: getReq.result.lastReceivedMessageTs
          });
        } else {
          func(null);
        }
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  getAllEndToEndSessions(txn, func) {
    var objectStore = txn.objectStore("sessions");
    var getReq = objectStore.openCursor();
    getReq.onsuccess = function () {
      try {
        var cursor = getReq.result;
        if (cursor) {
          func(cursor.value);
          cursor.continue();
        } else {
          func(null);
        }
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  storeEndToEndSession(deviceKey, sessionId, sessionInfo, txn) {
    var objectStore = txn.objectStore("sessions");
    objectStore.put({
      deviceKey,
      sessionId,
      session: sessionInfo.session,
      lastReceivedMessageTs: sessionInfo.lastReceivedMessageTs
    });
  }
  storeEndToEndSessionProblem(deviceKey, type, fixed) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      var txn = _this4.db.transaction("session_problems", "readwrite");
      var objectStore = txn.objectStore("session_problems");
      objectStore.put({
        deviceKey,
        type,
        fixed,
        time: Date.now()
      });
      yield promiseifyTxn(txn);
    })();
  }
  getEndToEndSessionProblem(deviceKey, timestamp) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      var result = null;
      var txn = _this5.db.transaction("session_problems", "readwrite");
      var objectStore = txn.objectStore("session_problems");
      var index = objectStore.index("deviceKey");
      var req = index.getAll(deviceKey);
      req.onsuccess = () => {
        var problems = req.result;
        if (!problems.length) {
          result = null;
          return;
        }
        problems.sort((a, b) => {
          return a.time - b.time;
        });
        var lastProblem = problems[problems.length - 1];
        for (var problem of problems) {
          if (problem.time > timestamp) {
            result = Object.assign({}, problem, {
              fixed: lastProblem.fixed
            });
            return;
          }
        }
        if (lastProblem.fixed) {
          result = null;
        } else {
          result = lastProblem;
        }
      };
      yield promiseifyTxn(txn);
      return result;
    })();
  }

  // FIXME: we should probably prune this when devices get deleted
  filterOutNotifiedErrorDevices(devices) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      var txn = _this6.db.transaction("notified_error_devices", "readwrite");
      var objectStore = txn.objectStore("notified_error_devices");
      var ret = [];
      yield Promise.all(devices.map(device => {
        return new Promise(resolve => {
          var {
            userId,
            deviceInfo
          } = device;
          var getReq = objectStore.get([userId, deviceInfo.deviceId]);
          getReq.onsuccess = function () {
            if (!getReq.result) {
              objectStore.put({
                userId,
                deviceId: deviceInfo.deviceId
              });
              ret.push(device);
            }
            resolve();
          };
        });
      }));
      return ret;
    })();
  }

  /**
   * Fetch a batch of Olm sessions from the database.
   *
   * Implementation of {@link CryptoStore.getEndToEndSessionsBatch}.
   */
  getEndToEndSessionsBatch() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      var result = [];
      yield _this7.doTxn("readonly", [IndexedDBCryptoStore.STORE_SESSIONS], txn => {
        var objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);
        var getReq = objectStore.openCursor();
        getReq.onsuccess = function () {
          try {
            var cursor = getReq.result;
            if (cursor) {
              result.push(cursor.value);
              if (result.length < SESSION_BATCH_SIZE) {
                cursor.continue();
              }
            }
          } catch (e) {
            abortWithException(txn, e);
          }
        };
      });
      if (result.length === 0) {
        // No sessions left.
        return null;
      }
      return result;
    })();
  }

  /**
   * Delete a batch of Olm sessions from the database.
   *
   * Implementation of {@link CryptoStore.deleteEndToEndSessionsBatch}.
   *
   * @internal
   */
  deleteEndToEndSessionsBatch(sessions) {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      yield _this8.doTxn("readwrite", [IndexedDBCryptoStore.STORE_SESSIONS], /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (txn) {
          try {
            var objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_SESSIONS);
            var _loop = function* _loop() {
              var req = objectStore.delete([deviceKey, sessionId]);
              yield new Promise(resolve => {
                req.onsuccess = resolve;
              });
            };
            for (var {
              deviceKey,
              sessionId
            } of sessions) {
              yield* _loop();
            }
          } catch (e) {
            abortWithException(txn, e);
          }
        });
        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    })();
  }

  // Inbound group sessions

  getEndToEndInboundGroupSession(senderCurve25519Key, sessionId, txn, func) {
    var session = false;
    var withheld = false;
    var objectStore = txn.objectStore("inbound_group_sessions");
    var getReq = objectStore.get([senderCurve25519Key, sessionId]);
    getReq.onsuccess = function () {
      try {
        if (getReq.result) {
          session = getReq.result.session;
        } else {
          session = null;
        }
        if (withheld !== false) {
          func(session, withheld);
        }
      } catch (e) {
        abortWithException(txn, e);
      }
    };
    var withheldObjectStore = txn.objectStore("inbound_group_sessions_withheld");
    var withheldGetReq = withheldObjectStore.get([senderCurve25519Key, sessionId]);
    withheldGetReq.onsuccess = function () {
      try {
        if (withheldGetReq.result) {
          withheld = withheldGetReq.result.session;
        } else {
          withheld = null;
        }
        if (session !== false) {
          func(session, withheld);
        }
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  getAllEndToEndInboundGroupSessions(txn, func) {
    var objectStore = txn.objectStore("inbound_group_sessions");
    var getReq = objectStore.openCursor();
    getReq.onsuccess = function () {
      var cursor = getReq.result;
      if (cursor) {
        try {
          func({
            senderKey: cursor.value.senderCurve25519Key,
            sessionId: cursor.value.sessionId,
            sessionData: cursor.value.session
          });
        } catch (e) {
          abortWithException(txn, e);
        }
        cursor.continue();
      } else {
        try {
          func(null);
        } catch (e) {
          abortWithException(txn, e);
        }
      }
    };
  }
  addEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
    var objectStore = txn.objectStore("inbound_group_sessions");
    var addReq = objectStore.add({
      senderCurve25519Key,
      sessionId,
      session: sessionData
    });
    addReq.onerror = ev => {
      var _addReq$error;
      if (((_addReq$error = addReq.error) === null || _addReq$error === void 0 ? void 0 : _addReq$error.name) === "ConstraintError") {
        // This stops the error from triggering the txn's onerror
        ev.stopPropagation();
        // ...and this stops it from aborting the transaction
        ev.preventDefault();
        logger.log("Ignoring duplicate inbound group session: " + senderCurve25519Key + " / " + sessionId);
      } else {
        abortWithException(txn, new Error("Failed to add inbound group session: " + addReq.error));
      }
    };
  }
  storeEndToEndInboundGroupSession(senderCurve25519Key, sessionId, sessionData, txn) {
    var objectStore = txn.objectStore("inbound_group_sessions");
    objectStore.put({
      senderCurve25519Key,
      sessionId,
      session: sessionData
    });
  }
  storeEndToEndInboundGroupSessionWithheld(senderCurve25519Key, sessionId, sessionData, txn) {
    var objectStore = txn.objectStore("inbound_group_sessions_withheld");
    objectStore.put({
      senderCurve25519Key,
      sessionId,
      session: sessionData
    });
  }

  /**
   * Count the number of Megolm sessions in the database.
   *
   * Implementation of {@link CryptoStore.countEndToEndInboundGroupSessions}.
   *
   * @internal
   */
  countEndToEndInboundGroupSessions() {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      var result = 0;
      yield _this9.doTxn("readonly", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], txn => {
        var sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);
        var countReq = sessionStore.count();
        countReq.onsuccess = () => {
          result = countReq.result;
        };
      });
      return result;
    })();
  }

  /**
   * Fetch a batch of Megolm sessions from the database.
   *
   * Implementation of {@link CryptoStore.getEndToEndInboundGroupSessionsBatch}.
   */
  getEndToEndInboundGroupSessionsBatch() {
    var _this10 = this;
    return _asyncToGenerator(function* () {
      var result = [];
      yield _this10.doTxn("readonly", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, IndexedDBCryptoStore.STORE_BACKUP], txn => {
        var sessionStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);
        var backupStore = txn.objectStore(IndexedDBCryptoStore.STORE_BACKUP);
        var getReq = sessionStore.openCursor();
        getReq.onsuccess = function () {
          try {
            var cursor = getReq.result;
            if (cursor) {
              var backupGetReq = backupStore.get(cursor.key);
              backupGetReq.onsuccess = () => {
                result.push({
                  senderKey: cursor.value.senderCurve25519Key,
                  sessionId: cursor.value.sessionId,
                  sessionData: cursor.value.session,
                  needsBackup: backupGetReq.result !== undefined
                });
                if (result.length < SESSION_BATCH_SIZE) {
                  cursor.continue();
                }
              };
            }
          } catch (e) {
            abortWithException(txn, e);
          }
        };
      });
      if (result.length === 0) {
        // No sessions left.
        return null;
      }
      return result;
    })();
  }

  /**
   * Delete a batch of Megolm sessions from the database.
   *
   * Implementation of {@link CryptoStore.deleteEndToEndInboundGroupSessionsBatch}.
   *
   * @internal
   */
  deleteEndToEndInboundGroupSessionsBatch(sessions) {
    var _this11 = this;
    return _asyncToGenerator(function* () {
      yield _this11.doTxn("readwrite", [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS], /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator(function* (txn) {
          try {
            var objectStore = txn.objectStore(IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS);
            var _loop2 = function* _loop2() {
              var req = objectStore.delete([senderKey, sessionId]);
              yield new Promise(resolve => {
                req.onsuccess = resolve;
              });
            };
            for (var {
              senderKey,
              sessionId
            } of sessions) {
              yield* _loop2();
            }
          } catch (e) {
            abortWithException(txn, e);
          }
        });
        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    })();
  }
  getEndToEndDeviceData(txn, func) {
    var objectStore = txn.objectStore("device_data");
    var getReq = objectStore.get("-");
    getReq.onsuccess = function () {
      try {
        func(getReq.result || null);
      } catch (e) {
        abortWithException(txn, e);
      }
    };
  }
  storeEndToEndDeviceData(deviceData, txn) {
    var objectStore = txn.objectStore("device_data");
    objectStore.put(deviceData, "-");
  }
  storeEndToEndRoom(roomId, roomInfo, txn) {
    var objectStore = txn.objectStore("rooms");
    objectStore.put(roomInfo, roomId);
  }
  getEndToEndRooms(txn, func) {
    var rooms = {};
    var objectStore = txn.objectStore("rooms");
    var getReq = objectStore.openCursor();
    getReq.onsuccess = function () {
      var cursor = getReq.result;
      if (cursor) {
        rooms[cursor.key] = cursor.value;
        cursor.continue();
      } else {
        try {
          func(rooms);
        } catch (e) {
          abortWithException(txn, e);
        }
      }
    };
  }

  // session backups

  getSessionsNeedingBackup(limit) {
    return new Promise((resolve, reject) => {
      var sessions = [];
      var txn = this.db.transaction(["sessions_needing_backup", "inbound_group_sessions"], "readonly");
      txn.onerror = reject;
      txn.oncomplete = function () {
        resolve(sessions);
      };
      var objectStore = txn.objectStore("sessions_needing_backup");
      var sessionStore = txn.objectStore("inbound_group_sessions");
      var getReq = objectStore.openCursor();
      getReq.onsuccess = function () {
        var cursor = getReq.result;
        if (cursor) {
          var sessionGetReq = sessionStore.get(cursor.key);
          sessionGetReq.onsuccess = function () {
            sessions.push({
              senderKey: sessionGetReq.result.senderCurve25519Key,
              sessionId: sessionGetReq.result.sessionId,
              sessionData: sessionGetReq.result.session
            });
          };
          if (!limit || sessions.length < limit) {
            cursor.continue();
          }
        }
      };
    });
  }
  countSessionsNeedingBackup(txn) {
    if (!txn) {
      txn = this.db.transaction("sessions_needing_backup", "readonly");
    }
    var objectStore = txn.objectStore("sessions_needing_backup");
    return new Promise((resolve, reject) => {
      var req = objectStore.count();
      req.onerror = reject;
      req.onsuccess = () => resolve(req.result);
    });
  }
  unmarkSessionsNeedingBackup(sessions, txn) {
    var _this12 = this;
    return _asyncToGenerator(function* () {
      if (!txn) {
        txn = _this12.db.transaction("sessions_needing_backup", "readwrite");
      }
      var objectStore = txn.objectStore("sessions_needing_backup");
      yield Promise.all(sessions.map(session => {
        return new Promise((resolve, reject) => {
          var req = objectStore.delete([session.senderKey, session.sessionId]);
          req.onsuccess = resolve;
          req.onerror = reject;
        });
      }));
    })();
  }
  markSessionsNeedingBackup(sessions, txn) {
    var _this13 = this;
    return _asyncToGenerator(function* () {
      if (!txn) {
        txn = _this13.db.transaction("sessions_needing_backup", "readwrite");
      }
      var objectStore = txn.objectStore("sessions_needing_backup");
      yield Promise.all(sessions.map(session => {
        return new Promise((resolve, reject) => {
          var req = objectStore.put({
            senderCurve25519Key: session.senderKey,
            sessionId: session.sessionId
          });
          req.onsuccess = resolve;
          req.onerror = reject;
        });
      }));
    })();
  }
  addSharedHistoryInboundGroupSession(roomId, senderKey, sessionId, txn) {
    if (!txn) {
      txn = this.db.transaction("shared_history_inbound_group_sessions", "readwrite");
    }
    var objectStore = txn.objectStore("shared_history_inbound_group_sessions");
    var req = objectStore.get([roomId]);
    req.onsuccess = () => {
      var {
        sessions
      } = req.result || {
        sessions: []
      };
      sessions.push([senderKey, sessionId]);
      objectStore.put({
        roomId,
        sessions
      });
    };
  }
  getSharedHistoryInboundGroupSessions(roomId, txn) {
    if (!txn) {
      txn = this.db.transaction("shared_history_inbound_group_sessions", "readonly");
    }
    var objectStore = txn.objectStore("shared_history_inbound_group_sessions");
    var req = objectStore.get([roomId]);
    return new Promise((resolve, reject) => {
      req.onsuccess = () => {
        var {
          sessions
        } = req.result || {
          sessions: []
        };
        resolve(sessions);
      };
      req.onerror = reject;
    });
  }
  addParkedSharedHistory(roomId, parkedData, txn) {
    if (!txn) {
      txn = this.db.transaction("parked_shared_history", "readwrite");
    }
    var objectStore = txn.objectStore("parked_shared_history");
    var req = objectStore.get([roomId]);
    req.onsuccess = () => {
      var {
        parked
      } = req.result || {
        parked: []
      };
      parked.push(parkedData);
      objectStore.put({
        roomId,
        parked
      });
    };
  }
  takeParkedSharedHistory(roomId, txn) {
    if (!txn) {
      txn = this.db.transaction("parked_shared_history", "readwrite");
    }
    var cursorReq = txn.objectStore("parked_shared_history").openCursor(roomId);
    return new Promise((resolve, reject) => {
      cursorReq.onsuccess = () => {
        var cursor = cursorReq.result;
        if (!cursor) {
          resolve([]);
          return;
        }
        var data = cursor.value;
        cursor.delete();
        resolve(data);
      };
      cursorReq.onerror = reject;
    });
  }
  doTxn(mode, stores, func) {
    var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : logger;
    var startTime;
    var description;
    if (PROFILE_TRANSACTIONS) {
      var txnId = this.nextTxnId++;
      startTime = Date.now();
      description = "".concat(mode, " crypto store transaction ").concat(txnId, " in ").concat(stores);
      log.debug("Starting ".concat(description));
    }
    var txn = this.db.transaction(stores, mode);
    var promise = promiseifyTxn(txn);
    var result = func(txn);
    if (PROFILE_TRANSACTIONS) {
      promise.then(() => {
        var elapsedTime = Date.now() - startTime;
        log.debug("Finished ".concat(description, ", took ").concat(elapsedTime, " ms"));
      }, () => {
        var elapsedTime = Date.now() - startTime;
        log.error("Failed ".concat(description, ", took ").concat(elapsedTime, " ms"));
      });
    }
    return promise.then(() => {
      return result;
    });
  }
}
var DB_MIGRATIONS = [db => {
  createDatabase(db);
}, db => {
  db.createObjectStore("account");
}, db => {
  var sessionsStore = db.createObjectStore("sessions", {
    keyPath: ["deviceKey", "sessionId"]
  });
  sessionsStore.createIndex("deviceKey", "deviceKey");
}, db => {
  db.createObjectStore("inbound_group_sessions", {
    keyPath: ["senderCurve25519Key", "sessionId"]
  });
}, db => {
  db.createObjectStore("device_data");
}, db => {
  db.createObjectStore("rooms");
}, db => {
  db.createObjectStore("sessions_needing_backup", {
    keyPath: ["senderCurve25519Key", "sessionId"]
  });
}, db => {
  db.createObjectStore("inbound_group_sessions_withheld", {
    keyPath: ["senderCurve25519Key", "sessionId"]
  });
}, db => {
  var problemsStore = db.createObjectStore("session_problems", {
    keyPath: ["deviceKey", "time"]
  });
  problemsStore.createIndex("deviceKey", "deviceKey");
  db.createObjectStore("notified_error_devices", {
    keyPath: ["userId", "deviceId"]
  });
}, db => {
  db.createObjectStore("shared_history_inbound_group_sessions", {
    keyPath: ["roomId"]
  });
}, db => {
  db.createObjectStore("parked_shared_history", {
    keyPath: ["roomId"]
  });
}
// Expand as needed.
];
export var VERSION = DB_MIGRATIONS.length;
export function upgradeDatabase(db, oldVersion) {
  logger.log("Upgrading IndexedDBCryptoStore from version ".concat(oldVersion) + " to ".concat(VERSION));
  DB_MIGRATIONS.forEach((migration, index) => {
    if (oldVersion <= index) migration(db);
  });
}
function createDatabase(db) {
  var outgoingRoomKeyRequestsStore = db.createObjectStore("outgoingRoomKeyRequests", {
    keyPath: "requestId"
  });

  // we assume that the RoomKeyRequestBody will have room_id and session_id
  // properties, to make the index efficient.
  outgoingRoomKeyRequestsStore.createIndex("session", ["requestBody.room_id", "requestBody.session_id"]);
  outgoingRoomKeyRequestsStore.createIndex("state", "state");
}
/*
 * Aborts a transaction with a given exception
 * The transaction promise will be rejected with this exception.
 */
function abortWithException(txn, e) {
  // We cheekily stick our exception onto the transaction object here
  // We could alternatively make the thing we pass back to the app
  // an object containing the transaction and exception.
  txn._mx_abortexception = e;
  try {
    txn.abort();
  } catch (_unused) {
    // sometimes we won't be able to abort the transaction
    // (ie. if it's aborted or completed)
  }
}
function promiseifyTxn(txn) {
  return new Promise((resolve, reject) => {
    txn.oncomplete = () => {
      if (txn._mx_abortexception !== undefined) {
        reject(txn._mx_abortexception);
      }
      resolve(null);
    };
    txn.onerror = event => {
      if (txn._mx_abortexception !== undefined) {
        reject(txn._mx_abortexception);
      } else {
        logger.log("Error performing indexeddb txn", event);
        reject(txn.error);
      }
    };
    txn.onabort = event => {
      if (txn._mx_abortexception !== undefined) {
        reject(txn._mx_abortexception);
      } else {
        logger.log("Error performing indexeddb txn", event);
        reject(txn.error);
      }
    };
  });
}
//# sourceMappingURL=indexeddb-crypto-store-backend.js.map