import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2018 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Short Authentication String (SAS) verification.
 */

import anotherjson from "another-json";
import { VerificationBase as Base, SwitchStartEventError } from "./Base.js";
import { errorFactory, newInvalidMessageError, newKeyMismatchError, newUnknownMethodError, newUserCancelledError } from "./Error.js";
import { logger } from "../../logger.js";
import { generateDecimalSas } from "./SASDecimal.js";
import { EventType } from "../../@types/event.js";
import { VerifierEvent } from "../../crypto-api/verification.js";
import { VerificationMethod } from "../../types.js";

// backwards-compatibility exports

var START_TYPE = EventType.KeyVerificationStart;
var EVENTS = [EventType.KeyVerificationAccept, EventType.KeyVerificationKey, EventType.KeyVerificationMac];
var olmutil;
var newMismatchedSASError = errorFactory("m.mismatched_sas", "Mismatched short authentication string");
var newMismatchedCommitmentError = errorFactory("m.mismatched_commitment", "Mismatched commitment");

// This list was generated from the data in the Matrix specification [1] with the following command:
//
//    jq  -r '.[] |  "    [\"" + .emoji + "\", \"" + (.description|ascii_downcase) + "\"], // " + (.number|tostring)' sas-emoji.json
//
// [1]: https://github.com/matrix-org/matrix-spec/blob/main/data-definitions/sas-emoji.json
var emojiMapping = [["🐶", "dog"],
// 0
["🐱", "cat"],
// 1
["🦁", "lion"],
// 2
["🐎", "horse"],
// 3
["🦄", "unicorn"],
// 4
["🐷", "pig"],
// 5
["🐘", "elephant"],
// 6
["🐰", "rabbit"],
// 7
["🐼", "panda"],
// 8
["🐓", "rooster"],
// 9
["🐧", "penguin"],
// 10
["🐢", "turtle"],
// 11
["🐟", "fish"],
// 12
["🐙", "octopus"],
// 13
["🦋", "butterfly"],
// 14
["🌷", "flower"],
// 15
["🌳", "tree"],
// 16
["🌵", "cactus"],
// 17
["🍄", "mushroom"],
// 18
["🌏", "globe"],
// 19
["🌙", "moon"],
// 20
["☁️", "cloud"],
// 21
["🔥", "fire"],
// 22
["🍌", "banana"],
// 23
["🍎", "apple"],
// 24
["🍓", "strawberry"],
// 25
["🌽", "corn"],
// 26
["🍕", "pizza"],
// 27
["🎂", "cake"],
// 28
["❤️", "heart"],
// 29
["😀", "smiley"],
// 30
["🤖", "robot"],
// 31
["🎩", "hat"],
// 32
["👓", "glasses"],
// 33
["🔧", "spanner"],
// 34
["🎅", "santa"],
// 35
["👍", "thumbs up"],
// 36
["☂️", "umbrella"],
// 37
["⌛", "hourglass"],
// 38
["⏰", "clock"],
// 39
["🎁", "gift"],
// 40
["💡", "light bulb"],
// 41
["📕", "book"],
// 42
["✏️", "pencil"],
// 43
["📎", "paperclip"],
// 44
["✂️", "scissors"],
// 45
["🔒", "lock"],
// 46
["🔑", "key"],
// 47
["🔨", "hammer"],
// 48
["☎️", "telephone"],
// 49
["🏁", "flag"],
// 50
["🚂", "train"],
// 51
["🚲", "bicycle"],
// 52
["✈️", "aeroplane"],
// 53
["🚀", "rocket"],
// 54
["🏆", "trophy"],
// 55
["⚽", "ball"],
// 56
["🎸", "guitar"],
// 57
["🎺", "trumpet"],
// 58
["🔔", "bell"],
// 59
["⚓", "anchor"],
// 60
["🎧", "headphones"],
// 61
["📁", "folder"],
// 62
["📌", "pin"] // 63
];
function generateEmojiSas(sasBytes) {
  var emojis = [
  // just like base64 encoding
  sasBytes[0] >> 2, (sasBytes[0] & 0x3) << 4 | sasBytes[1] >> 4, (sasBytes[1] & 0xf) << 2 | sasBytes[2] >> 6, sasBytes[2] & 0x3f, sasBytes[3] >> 2, (sasBytes[3] & 0x3) << 4 | sasBytes[4] >> 4, (sasBytes[4] & 0xf) << 2 | sasBytes[5] >> 6];
  return emojis.map(num => emojiMapping[num]);
}
var sasGenerators = {
  decimal: generateDecimalSas,
  emoji: generateEmojiSas
};
function generateSas(sasBytes, methods) {
  var sas = {};
  for (var method of methods) {
    if (method in sasGenerators) {
      // @ts-ignore - ts doesn't like us mixing types like this
      sas[method] = sasGenerators[method](Array.from(sasBytes));
    }
  }
  return sas;
}
var macMethods = {
  "hkdf-hmac-sha256": "calculate_mac",
  "org.matrix.msc3783.hkdf-hmac-sha256": "calculate_mac_fixed_base64",
  "hkdf-hmac-sha256.v2": "calculate_mac_fixed_base64",
  "hmac-sha256": "calculate_mac_long_kdf"
};
function calculateMAC(olmSAS, method) {
  return function (input, info) {
    var mac = olmSAS[macMethods[method]](input, info);
    logger.log("SAS calculateMAC:", method, [input, info], mac);
    return mac;
  };
}
var calculateKeyAgreement = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  "curve25519-hkdf-sha256": function curve25519HkdfSha256(sas, olmSAS, bytes) {
    var ourInfo = "".concat(sas.baseApis.getUserId(), "|").concat(sas.baseApis.deviceId, "|") + "".concat(sas.ourSASPubKey, "|");
    var theirInfo = "".concat(sas.userId, "|").concat(sas.deviceId, "|").concat(sas.theirSASPubKey, "|");
    var sasInfo = "MATRIX_KEY_VERIFICATION_SAS|" + (sas.initiatedByMe ? ourInfo + theirInfo : theirInfo + ourInfo) + sas.channel.transactionId;
    return olmSAS.generate_bytes(sasInfo, bytes);
  },
  "curve25519": function curve25519(sas, olmSAS, bytes) {
    var ourInfo = "".concat(sas.baseApis.getUserId()).concat(sas.baseApis.deviceId);
    var theirInfo = "".concat(sas.userId).concat(sas.deviceId);
    var sasInfo = "MATRIX_KEY_VERIFICATION_SAS" + (sas.initiatedByMe ? ourInfo + theirInfo : theirInfo + ourInfo) + sas.channel.transactionId;
    return olmSAS.generate_bytes(sasInfo, bytes);
  }
};
/* lists of algorithms/methods that are supported.  The key agreement, hashes,
 * and MAC lists should be sorted in order of preference (most preferred
 * first).
 */
var KEY_AGREEMENT_LIST = ["curve25519-hkdf-sha256", "curve25519"];
var HASHES_LIST = ["sha256"];
var MAC_LIST = ["hkdf-hmac-sha256.v2", "org.matrix.msc3783.hkdf-hmac-sha256", "hkdf-hmac-sha256", "hmac-sha256"];
var SAS_LIST = Object.keys(sasGenerators);
var KEY_AGREEMENT_SET = new Set(KEY_AGREEMENT_LIST);
var HASHES_SET = new Set(HASHES_LIST);
var MAC_SET = new Set(MAC_LIST);
var SAS_SET = new Set(SAS_LIST);
function intersection(anArray, aSet) {
  return Array.isArray(anArray) ? anArray.filter(x => aSet.has(x)) : [];
}

/** @deprecated use VerifierEvent */

/** @deprecated use VerifierEvent */
export var SasEvent = VerifierEvent;

/** @deprecated Avoid referencing this class directly; instead use {@link Crypto.Verifier}. */
export class SAS extends Base {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "waitingForAccept", void 0);
    _defineProperty(this, "ourSASPubKey", void 0);
    _defineProperty(this, "theirSASPubKey", void 0);
    _defineProperty(this, "sasEvent", void 0);
    _defineProperty(this, "doVerification", /*#__PURE__*/_asyncToGenerator(function* () {
      yield globalThis.Olm.init();
      olmutil = olmutil || new globalThis.Olm.Utility();

      // make sure user's keys are downloaded
      yield _this.baseApis.downloadKeys([_this.userId]);
      var retry = false;
      do {
        try {
          if (_this.initiatedByMe) {
            return yield _this.doSendVerification();
          } else {
            return yield _this.doRespondVerification();
          }
        } catch (err) {
          if (err instanceof SwitchStartEventError) {
            // this changes what initiatedByMe returns
            _this.startEvent = err.startEvent;
            retry = true;
          } else {
            throw err;
          }
        }
      } while (retry);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get NAME() {
    return VerificationMethod.Sas;
  }
  get events() {
    return EVENTS;
  }
  canSwitchStartEvent(event) {
    if (event.getType() !== START_TYPE) {
      return false;
    }
    var content = event.getContent();
    return (content === null || content === void 0 ? void 0 : content.method) === SAS.NAME && !!this.waitingForAccept;
  }
  sendStart() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var startContent = _this2.channel.completeContent(START_TYPE, {
        method: SAS.NAME,
        from_device: _this2.baseApis.deviceId,
        key_agreement_protocols: KEY_AGREEMENT_LIST,
        hashes: HASHES_LIST,
        message_authentication_codes: MAC_LIST,
        // FIXME: allow app to specify what SAS methods can be used
        short_authentication_string: SAS_LIST
      });
      yield _this2.channel.sendCompleted(START_TYPE, startContent);
      return startContent;
    })();
  }
  verifyAndCheckMAC(keyAgreement, sasMethods, olmSAS, macMethod) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      var sasBytes = calculateKeyAgreement[keyAgreement](_this3, olmSAS, 6);
      var verifySAS = new Promise((resolve, reject) => {
        _this3.sasEvent = {
          sas: generateSas(sasBytes, sasMethods),
          confirm: function () {
            var _confirm = _asyncToGenerator(function* () {
              try {
                yield _this3.sendMAC(olmSAS, macMethod);
                resolve();
              } catch (err) {
                reject(err);
              }
            });
            function confirm() {
              return _confirm.apply(this, arguments);
            }
            return confirm;
          }(),
          cancel: () => reject(newUserCancelledError()),
          mismatch: () => reject(newMismatchedSASError())
        };
        _this3.emit(SasEvent.ShowSas, _this3.sasEvent);
      });
      var [e] = yield Promise.all([_this3.waitForEvent(EventType.KeyVerificationMac).then(e => {
        // we don't expect any more messages from the other
        // party, and they may send a m.key.verification.done
        // when they're done on their end
        _this3.expectedEvent = EventType.KeyVerificationDone;
        return e;
      }), verifySAS]);
      var content = e.getContent();
      yield _this3.checkMAC(olmSAS, content, macMethod);
    })();
  }
  doSendVerification() {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      _this4.waitingForAccept = true;
      var startContent;
      if (_this4.startEvent) {
        startContent = _this4.channel.completedContentFromEvent(_this4.startEvent);
      } else {
        startContent = yield _this4.sendStart();
      }

      // we might have switched to a different start event,
      // but was we didn't call _waitForEvent there was no
      // call that could throw yet. So check manually that
      // we're still on the initiator side
      if (!_this4.initiatedByMe) {
        throw new SwitchStartEventError(_this4.startEvent);
      }
      var e;
      try {
        e = yield _this4.waitForEvent(EventType.KeyVerificationAccept);
      } finally {
        _this4.waitingForAccept = false;
      }
      var content = e.getContent();
      var sasMethods = intersection(content.short_authentication_string, SAS_SET);
      if (!(KEY_AGREEMENT_SET.has(content.key_agreement_protocol) && HASHES_SET.has(content.hash) && MAC_SET.has(content.message_authentication_code) && sasMethods.length)) {
        throw newUnknownMethodError();
      }
      if (typeof content.commitment !== "string") {
        throw newInvalidMessageError();
      }
      var keyAgreement = content.key_agreement_protocol;
      var macMethod = content.message_authentication_code;
      var hashCommitment = content.commitment;
      var olmSAS = new globalThis.Olm.SAS();
      try {
        _this4.ourSASPubKey = olmSAS.get_pubkey();
        yield _this4.send(EventType.KeyVerificationKey, {
          key: _this4.ourSASPubKey
        });
        e = yield _this4.waitForEvent(EventType.KeyVerificationKey);
        // FIXME: make sure event is properly formed
        content = e.getContent();
        var commitmentStr = content.key + anotherjson.stringify(startContent);
        // TODO: use selected hash function (when we support multiple)
        if (olmutil.sha256(commitmentStr) !== hashCommitment) {
          throw newMismatchedCommitmentError();
        }
        _this4.theirSASPubKey = content.key;
        olmSAS.set_their_key(content.key);
        yield _this4.verifyAndCheckMAC(keyAgreement, sasMethods, olmSAS, macMethod);
      } finally {
        olmSAS.free();
      }
    })();
  }
  doRespondVerification() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      // as m.related_to is not included in the encrypted content in e2e rooms,
      // we need to make sure it is added
      var content = _this5.channel.completedContentFromEvent(_this5.startEvent);

      // Note: we intersect using our pre-made lists, rather than the sets,
      // so that the result will be in our order of preference.  Then
      // fetching the first element from the array will give our preferred
      // method out of the ones offered by the other party.
      var keyAgreement = intersection(KEY_AGREEMENT_LIST, new Set(content.key_agreement_protocols))[0];
      var hashMethod = intersection(HASHES_LIST, new Set(content.hashes))[0];
      var macMethod = intersection(MAC_LIST, new Set(content.message_authentication_codes))[0];
      // FIXME: allow app to specify what SAS methods can be used
      var sasMethods = intersection(content.short_authentication_string, SAS_SET);
      if (!(keyAgreement !== undefined && hashMethod !== undefined && macMethod !== undefined && sasMethods.length)) {
        throw newUnknownMethodError();
      }
      var olmSAS = new globalThis.Olm.SAS();
      try {
        var commitmentStr = olmSAS.get_pubkey() + anotherjson.stringify(content);
        yield _this5.send(EventType.KeyVerificationAccept, {
          key_agreement_protocol: keyAgreement,
          hash: hashMethod,
          message_authentication_code: macMethod,
          short_authentication_string: sasMethods,
          // TODO: use selected hash function (when we support multiple)
          commitment: olmutil.sha256(commitmentStr)
        });
        var e = yield _this5.waitForEvent(EventType.KeyVerificationKey);
        // FIXME: make sure event is properly formed
        content = e.getContent();
        _this5.theirSASPubKey = content.key;
        olmSAS.set_their_key(content.key);
        _this5.ourSASPubKey = olmSAS.get_pubkey();
        yield _this5.send(EventType.KeyVerificationKey, {
          key: _this5.ourSASPubKey
        });
        yield _this5.verifyAndCheckMAC(keyAgreement, sasMethods, olmSAS, macMethod);
      } finally {
        olmSAS.free();
      }
    })();
  }
  sendMAC(olmSAS, method) {
    var mac = {};
    var keyList = [];
    var baseInfo = "MATRIX_KEY_VERIFICATION_MAC" + this.baseApis.getUserId() + this.baseApis.deviceId + this.userId + this.deviceId + this.channel.transactionId;
    var deviceKeyId = "ed25519:".concat(this.baseApis.deviceId);
    mac[deviceKeyId] = calculateMAC(olmSAS, method)(this.baseApis.getDeviceEd25519Key(), baseInfo + deviceKeyId);
    keyList.push(deviceKeyId);
    var crossSigningId = this.baseApis.getCrossSigningId();
    if (crossSigningId) {
      var crossSigningKeyId = "ed25519:".concat(crossSigningId);
      mac[crossSigningKeyId] = calculateMAC(olmSAS, method)(crossSigningId, baseInfo + crossSigningKeyId);
      keyList.push(crossSigningKeyId);
    }
    var keys = calculateMAC(olmSAS, method)(keyList.sort().join(","), baseInfo + "KEY_IDS");
    return this.send(EventType.KeyVerificationMac, {
      mac,
      keys
    });
  }
  checkMAC(olmSAS, content, method) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      var baseInfo = "MATRIX_KEY_VERIFICATION_MAC" + _this6.userId + _this6.deviceId + _this6.baseApis.getUserId() + _this6.baseApis.deviceId + _this6.channel.transactionId;
      if (content.keys !== calculateMAC(olmSAS, method)(Object.keys(content.mac).sort().join(","), baseInfo + "KEY_IDS")) {
        throw newKeyMismatchError();
      }
      yield _this6.verifyKeys(_this6.userId, content.mac, (keyId, device, keyInfo) => {
        if (keyInfo !== calculateMAC(olmSAS, method)(device.keys[keyId], baseInfo + keyId)) {
          throw newKeyMismatchError();
        }
      });
    })();
  }
  getShowSasCallbacks() {
    var _this$sasEvent;
    return (_this$sasEvent = this.sasEvent) !== null && _this$sasEvent !== void 0 ? _this$sasEvent : null;
  }
}
//# sourceMappingURL=SAS.js.map