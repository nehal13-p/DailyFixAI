import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2018 - 2021 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * QR code key verification.
 */

import { VerificationBase as Base } from "./Base.js";
import { newKeyMismatchError, newUserCancelledError } from "./Error.js";
import { decodeBase64, encodeUnpaddedBase64 } from "../../base64.js";
import { logger } from "../../logger.js";
import { VerifierEvent } from "../../crypto-api/verification.js";
import { VerificationMethod } from "../../types.js";
export var SHOW_QR_CODE_METHOD = VerificationMethod.ShowQrCode;
export var SCAN_QR_CODE_METHOD = VerificationMethod.ScanQrCode;

/** @deprecated use VerifierEvent */

/** @deprecated use VerifierEvent */
export var QrCodeEvent = VerifierEvent;

/** @deprecated Avoid referencing this class directly; instead use {@link Crypto.Verifier}. */
export class ReciprocateQRCode extends Base {
  constructor() {
    var _this;
    super(...arguments);
    _this = this;
    _defineProperty(this, "reciprocateQREvent", void 0);
    _defineProperty(this, "doVerification", /*#__PURE__*/_asyncToGenerator(function* () {
      if (!_this.startEvent) {
        // TODO: Support scanning QR codes
        throw new Error("It is not currently possible to start verification" + "with this method yet.");
      }
      var {
        qrCodeData
      } = _this.request;
      // 1. check the secret
      if (_this.startEvent.getContent()["secret"] !== (qrCodeData === null || qrCodeData === void 0 ? void 0 : qrCodeData.encodedSharedSecret)) {
        throw newKeyMismatchError();
      }

      // 2. ask if other user shows shield as well
      yield new Promise((resolve, reject) => {
        _this.reciprocateQREvent = {
          confirm: resolve,
          cancel: () => reject(newUserCancelledError())
        };
        _this.emit(QrCodeEvent.ShowReciprocateQr, _this.reciprocateQREvent);
      });

      // 3. determine key to sign / mark as trusted
      var keys = {};
      switch (qrCodeData === null || qrCodeData === void 0 ? void 0 : qrCodeData.mode) {
        case Mode.VerifyOtherUser:
          {
            // add master key to keys to be signed, only if we're not doing self-verification
            var masterKey = qrCodeData.otherUserMasterKey;
            keys["ed25519:".concat(masterKey)] = masterKey;
            break;
          }
        case Mode.VerifySelfTrusted:
          {
            var deviceId = _this.request.targetDevice.deviceId;
            keys["ed25519:".concat(deviceId)] = qrCodeData.otherDeviceKey;
            break;
          }
        case Mode.VerifySelfUntrusted:
          {
            var _masterKey = qrCodeData.myMasterKey;
            keys["ed25519:".concat(_masterKey)] = _masterKey;
            break;
          }
      }

      // 4. sign the key (or mark own MSK as verified in case of MODE_VERIFY_SELF_TRUSTED)
      yield _this.verifyKeys(_this.userId, keys, (keyId, device, keyInfo) => {
        // make sure the device has the expected keys
        var targetKey = keys[keyId];
        if (!targetKey) throw newKeyMismatchError();
        if (keyInfo !== targetKey) {
          logger.error("key ID from key info does not match");
          throw newKeyMismatchError();
        }
        for (var deviceKeyId in device.keys) {
          if (!deviceKeyId.startsWith("ed25519")) continue;
          var deviceTargetKey = keys[deviceKeyId];
          if (!deviceTargetKey) throw newKeyMismatchError();
          if (device.keys[deviceKeyId] !== deviceTargetKey) {
            logger.error("master key does not match");
            throw newKeyMismatchError();
          }
        }
      });
    }));
  }
  static factory(channel, baseApis, userId, deviceId, startEvent, request) {
    return new ReciprocateQRCode(channel, baseApis, userId, deviceId, startEvent, request);
  }

  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get NAME() {
    return "m.reciprocate.v1";
  }
  getReciprocateQrCodeCallbacks() {
    var _this$reciprocateQREv;
    return (_this$reciprocateQREv = this.reciprocateQREvent) !== null && _this$reciprocateQREv !== void 0 ? _this$reciprocateQREv : null;
  }
}
var CODE_VERSION = 0x02; // the version of binary QR codes we support
var BINARY_PREFIX = "MATRIX"; // ASCII, used to prefix the binary format
var Mode = /*#__PURE__*/function (Mode) {
  Mode[Mode["VerifyOtherUser"] = 0] = "VerifyOtherUser";
  Mode[Mode["VerifySelfTrusted"] = 1] = "VerifySelfTrusted";
  Mode[Mode["VerifySelfUntrusted"] = 2] = "VerifySelfUntrusted";
  return Mode;
}(Mode || {}); // We do not trust the master key
export class QRCodeData {
  constructor(mode, sharedSecret,
  // only set when mode is MODE_VERIFY_OTHER_USER, master key of other party at time of generating QR code
  otherUserMasterKey,
  // only set when mode is MODE_VERIFY_SELF_TRUSTED, device key of other party at time of generating QR code
  otherDeviceKey,
  // only set when mode is MODE_VERIFY_SELF_UNTRUSTED, own master key at time of generating QR code
  myMasterKey, buffer) {
    this.mode = mode;
    this.sharedSecret = sharedSecret;
    this.otherUserMasterKey = otherUserMasterKey;
    this.otherDeviceKey = otherDeviceKey;
    this.myMasterKey = myMasterKey;
    this.buffer = buffer;
  }
  static create(request, client) {
    return _asyncToGenerator(function* () {
      var sharedSecret = QRCodeData.generateSharedSecret();
      var mode = QRCodeData.determineMode(request, client);
      var otherUserMasterKey = null;
      var otherDeviceKey = null;
      var myMasterKey = null;
      if (mode === Mode.VerifyOtherUser) {
        var otherUserCrossSigningInfo = client.getStoredCrossSigningForUser(request.otherUserId);
        otherUserMasterKey = otherUserCrossSigningInfo.getId("master");
      } else if (mode === Mode.VerifySelfTrusted) {
        otherDeviceKey = yield QRCodeData.getOtherDeviceKey(request, client);
      } else if (mode === Mode.VerifySelfUntrusted) {
        var myUserId = client.getUserId();
        var myCrossSigningInfo = client.getStoredCrossSigningForUser(myUserId);
        myMasterKey = myCrossSigningInfo.getId("master");
      }
      var qrData = QRCodeData.generateQrData(request, client, mode, sharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey);
      var buffer = QRCodeData.generateBuffer(qrData);
      return new QRCodeData(mode, sharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey, buffer);
    })();
  }

  /**
   * The unpadded base64 encoded shared secret.
   */
  get encodedSharedSecret() {
    return this.sharedSecret;
  }
  getBuffer() {
    return this.buffer;
  }
  static generateSharedSecret() {
    var secretBytes = new Uint8Array(11);
    globalThis.crypto.getRandomValues(secretBytes);
    return encodeUnpaddedBase64(secretBytes);
  }
  static getOtherDeviceKey(request, client) {
    return _asyncToGenerator(function* () {
      var myUserId = client.getUserId();
      var otherDevice = request.targetDevice;
      var device = otherDevice.deviceId ? client.getStoredDevice(myUserId, otherDevice.deviceId) : undefined;
      if (!device) {
        throw new Error("could not find device " + (otherDevice === null || otherDevice === void 0 ? void 0 : otherDevice.deviceId));
      }
      return device.getFingerprint();
    })();
  }
  static determineMode(request, client) {
    var myUserId = client.getUserId();
    var otherUserId = request.otherUserId;
    var mode = Mode.VerifyOtherUser;
    if (myUserId === otherUserId) {
      // Mode changes depending on whether or not we trust the master cross signing key
      var myTrust = client.checkUserTrust(myUserId);
      if (myTrust.isCrossSigningVerified()) {
        mode = Mode.VerifySelfTrusted;
      } else {
        mode = Mode.VerifySelfUntrusted;
      }
    }
    return mode;
  }
  static generateQrData(request, client, mode, encodedSharedSecret, otherUserMasterKey, otherDeviceKey, myMasterKey) {
    var myUserId = client.getUserId();
    var transactionId = request.channel.transactionId;
    var qrData = {
      prefix: BINARY_PREFIX,
      version: CODE_VERSION,
      mode,
      transactionId,
      firstKeyB64: "",
      // worked out shortly
      secondKeyB64: "",
      // worked out shortly
      secretB64: encodedSharedSecret
    };
    var myCrossSigningInfo = client.getStoredCrossSigningForUser(myUserId);
    if (mode === Mode.VerifyOtherUser) {
      // First key is our master cross signing key
      qrData.firstKeyB64 = myCrossSigningInfo.getId("master");
      // Second key is the other user's master cross signing key
      qrData.secondKeyB64 = otherUserMasterKey;
    } else if (mode === Mode.VerifySelfTrusted) {
      // First key is our master cross signing key
      qrData.firstKeyB64 = myCrossSigningInfo.getId("master");
      qrData.secondKeyB64 = otherDeviceKey;
    } else if (mode === Mode.VerifySelfUntrusted) {
      // First key is our device's key
      qrData.firstKeyB64 = client.getDeviceEd25519Key();
      // Second key is what we think our master cross signing key is
      qrData.secondKeyB64 = myMasterKey;
    }
    return qrData;
  }
  static generateBuffer(qrData) {
    var buf = Buffer.alloc(0); // we'll concat our way through life

    var appendByte = b => {
      var tmpBuf = Buffer.from([b]);
      buf = Buffer.concat([buf, tmpBuf]);
    };
    var appendInt = i => {
      var tmpBuf = Buffer.alloc(2);
      tmpBuf.writeInt16BE(i, 0);
      buf = Buffer.concat([buf, tmpBuf]);
    };
    var appendStr = function appendStr(s, enc) {
      var withLengthPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var tmpBuf = Buffer.from(s, enc);
      if (withLengthPrefix) appendInt(tmpBuf.byteLength);
      buf = Buffer.concat([buf, tmpBuf]);
    };
    var appendEncBase64 = b64 => {
      var b = decodeBase64(b64);
      var tmpBuf = Buffer.from(b);
      buf = Buffer.concat([buf, tmpBuf]);
    };

    // Actually build the buffer for the QR code
    appendStr(qrData.prefix, "ascii", false);
    appendByte(qrData.version);
    appendByte(qrData.mode);
    appendStr(qrData.transactionId, "utf-8");
    appendEncBase64(qrData.firstKeyB64);
    appendEncBase64(qrData.secondKeyB64);
    appendEncBase64(qrData.secretB64);
    return buf;
  }
}
//# sourceMappingURL=QRCode.js.map