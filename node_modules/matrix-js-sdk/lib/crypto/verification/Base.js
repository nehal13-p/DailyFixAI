import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2018 New Vector Ltd
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * Base class for verification methods.
 */

import { MatrixEvent } from "../../models/event.js";
import { EventType } from "../../@types/event.js";
import { logger } from "../../logger.js";
import { DeviceInfo } from "../deviceinfo.js";
import { newTimeoutError } from "./Error.js";
import { requestKeysDuringVerification } from "../CrossSigning.js";
import { TypedEventEmitter } from "../../models/typed-event-emitter.js";
import { VerifierEvent } from "../../crypto-api/verification.js";
var timeoutException = new Error("Verification timed out");
export class SwitchStartEventError extends Error {
  constructor(startEvent) {
    super();
    this.startEvent = startEvent;
  }
}

/** @deprecated use VerifierEvent */

/** @deprecated use VerifierEvent */
export var VerificationEvent = VerifierEvent;

/** @deprecated use VerifierEventHandlerMap */

/** @deprecated Avoid referencing this class directly; instead use {@link Crypto.Verifier}. */
// The type parameters of VerificationBase are no longer used, but we need some placeholders to maintain
// backwards compatibility with applications that reference the class.
export class VerificationBase extends TypedEventEmitter {
  /**
   * Base class for verification methods.
   *
   * <p>Once a verifier object is created, the verification can be started by
   * calling the verify() method, which will return a promise that will
   * resolve when the verification is completed, or reject if it could not
   * complete.</p>
   *
   * <p>Subclasses must have a NAME class property.</p>
   *
   * @param channel - the verification channel to send verification messages over.
   * TODO: Channel types
   *
   * @param baseApis - base matrix api interface
   *
   * @param userId - the user ID that is being verified
   *
   * @param deviceId - the device ID that is being verified
   *
   * @param startEvent - the m.key.verification.start event that
   * initiated this verification, if any
   *
   * @param request - the key verification request object related to
   * this verification, if any
   */
  constructor(channel, baseApis, userId, deviceId, startEvent, request) {
    super();
    this.channel = channel;
    this.baseApis = baseApis;
    this.userId = userId;
    this.deviceId = deviceId;
    this.startEvent = startEvent;
    this.request = request;
    _defineProperty(this, "cancelled", false);
    _defineProperty(this, "_done", false);
    _defineProperty(this, "promise", null);
    _defineProperty(this, "transactionTimeoutTimer", null);
    _defineProperty(this, "expectedEvent", void 0);
    _defineProperty(this, "resolve", void 0);
    _defineProperty(this, "reject", void 0);
    _defineProperty(this, "resolveEvent", void 0);
    _defineProperty(this, "rejectEvent", void 0);
    _defineProperty(this, "started", void 0);
    _defineProperty(this, "doVerification", void 0);
  }
  get initiatedByMe() {
    // if there is no start event yet,
    // we probably want to send it,
    // which happens if we initiate
    if (!this.startEvent) {
      return true;
    }
    var sender = this.startEvent.getSender();
    var content = this.startEvent.getContent();
    return sender === this.baseApis.getUserId() && content.from_device === this.baseApis.getDeviceId();
  }
  get hasBeenCancelled() {
    return this.cancelled;
  }
  resetTimer() {
    logger.info("Refreshing/starting the verification transaction timeout timer");
    if (this.transactionTimeoutTimer !== null) {
      clearTimeout(this.transactionTimeoutTimer);
    }
    this.transactionTimeoutTimer = setTimeout(() => {
      if (!this._done && !this.cancelled) {
        logger.info("Triggering verification timeout");
        this.cancel(timeoutException);
      }
    }, 10 * 60 * 1000); // 10 minutes
  }
  endTimer() {
    if (this.transactionTimeoutTimer !== null) {
      clearTimeout(this.transactionTimeoutTimer);
      this.transactionTimeoutTimer = null;
    }
  }
  send(type, uncompletedContent) {
    return this.channel.send(type, uncompletedContent);
  }
  waitForEvent(type) {
    if (this._done) {
      return Promise.reject(new Error("Verification is already done"));
    }
    var existingEvent = this.request.getEventFromOtherParty(type);
    if (existingEvent) {
      return Promise.resolve(existingEvent);
    }
    this.expectedEvent = type;
    return new Promise((resolve, reject) => {
      this.resolveEvent = resolve;
      this.rejectEvent = reject;
    });
  }
  canSwitchStartEvent(event) {
    return false;
  }
  switchStartEvent(event) {
    if (this.canSwitchStartEvent(event)) {
      logger.log("Verification Base: switching verification start event", {
        restartingFlow: !!this.rejectEvent
      });
      if (this.rejectEvent) {
        var reject = this.rejectEvent;
        this.rejectEvent = undefined;
        reject(new SwitchStartEventError(event));
      } else {
        this.startEvent = event;
      }
    }
  }
  handleEvent(e) {
    if (this._done) {
      return;
    } else if (e.getType() === this.expectedEvent) {
      // if we receive an expected m.key.verification.done, then just
      // ignore it, since we don't need to do anything about it
      if (this.expectedEvent !== EventType.KeyVerificationDone) {
        var _this$resolveEvent;
        this.expectedEvent = undefined;
        this.rejectEvent = undefined;
        this.resetTimer();
        (_this$resolveEvent = this.resolveEvent) === null || _this$resolveEvent === void 0 || _this$resolveEvent.call(this, e);
      }
    } else if (e.getType() === EventType.KeyVerificationCancel) {
      var reject = this.reject;
      this.reject = undefined;
      // there is only promise to reject if verify has been called
      if (reject) {
        var content = e.getContent();
        var {
          reason,
          code
        } = content;
        reject(new Error("Other side cancelled verification " + "because ".concat(reason, " (").concat(code, ")")));
      }
    } else if (this.expectedEvent) {
      // only cancel if there is an event expected.
      // if there is no event expected, it means verify() wasn't called
      // and we're just replaying the timeline events when syncing
      // after a refresh when the events haven't been stored in the cache yet.
      var exception = new Error("Unexpected message: expecting " + this.expectedEvent + " but got " + e.getType());
      this.expectedEvent = undefined;
      if (this.rejectEvent) {
        var _reject = this.rejectEvent;
        this.rejectEvent = undefined;
        _reject(exception);
      }
      this.cancel(exception);
    }
  }
  done() {
    var _this = this;
    return _asyncToGenerator(function* () {
      _this.endTimer(); // always kill the activity timer
      if (!_this._done) {
        var _this$resolve;
        _this.request.onVerifierFinished();
        (_this$resolve = _this.resolve) === null || _this$resolve === void 0 || _this$resolve.call(_this);
        return requestKeysDuringVerification(_this.baseApis, _this.userId, _this.deviceId);
      }
    })();
  }
  cancel(e) {
    this.endTimer(); // always kill the activity timer
    if (!this._done) {
      this.cancelled = true;
      this.request.onVerifierCancelled();
      if (this.userId && this.deviceId) {
        // send a cancellation to the other user (if it wasn't
        // cancelled by the other user)
        if (e === timeoutException) {
          var timeoutEvent = newTimeoutError();
          this.send(timeoutEvent.getType(), timeoutEvent.getContent());
        } else if (e instanceof MatrixEvent) {
          var sender = e.getSender();
          if (sender !== this.userId) {
            var content = e.getContent();
            if (e.getType() === EventType.KeyVerificationCancel) {
              content.code = content.code || "m.unknown";
              content.reason = content.reason || content.body || "Unknown reason";
              this.send(EventType.KeyVerificationCancel, content);
            } else {
              this.send(EventType.KeyVerificationCancel, {
                code: "m.unknown",
                reason: content.body || "Unknown reason"
              });
            }
          }
        } else {
          this.send(EventType.KeyVerificationCancel, {
            code: "m.unknown",
            reason: e.toString()
          });
        }
      }
      if (this.promise !== null) {
        // when we cancel without a promise, we end up with a promise
        // but no reject function. If cancel is called again, we'd error.
        if (this.reject) this.reject(e);
      } else {
        // FIXME: this causes an "Uncaught promise" console message
        // if nothing ends up chaining this promise.
        this.promise = Promise.reject(e);
      }
      // Also emit a 'cancel' event that the app can listen for to detect cancellation
      // before calling verify()
      this.emit(VerificationEvent.Cancel, e);
    }
  }

  /**
   * Begin the key verification
   *
   * @returns Promise which resolves when the verification has
   *     completed.
   */
  verify() {
    var _this2 = this;
    if (this.promise) return this.promise;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = function () {
        _this2._done = true;
        _this2.endTimer();
        resolve(...arguments);
      };
      this.reject = e => {
        this._done = true;
        this.endTimer();
        reject(e);
      };
    });
    if (this.doVerification && !this.started) {
      this.started = true;
      this.resetTimer(); // restart the timeout
      new Promise((resolve, reject) => {
        var _deviceList$getStored;
        var crossSignId = (_deviceList$getStored = this.baseApis.crypto.deviceList.getStoredCrossSigningForUser(this.userId)) === null || _deviceList$getStored === void 0 ? void 0 : _deviceList$getStored.getId();
        if (crossSignId === this.deviceId) {
          reject(new Error("Device ID is the same as the cross-signing ID"));
        }
        resolve();
      }).then(() => this.doVerification()).then(this.done.bind(this), this.cancel.bind(this));
    }
    return this.promise;
  }
  verifyKeys(userId, keys, verifier) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      // we try to verify all the keys that we're told about, but we might
      // not know about all of them, so keep track of the keys that we know
      // about, and ignore the rest
      var verifiedDevices = [];
      for (var [_keyId, _keyInfo] of Object.entries(keys)) {
        var _deviceId = _keyId.split(":", 2)[1];
        var _device = _this3.baseApis.getStoredDevice(userId, _deviceId);
        if (_device) {
          verifier(_keyId, _device, _keyInfo);
          verifiedDevices.push([_deviceId, _keyId, _device.keys[_keyId]]);
        } else {
          var crossSigningInfo = _this3.baseApis.crypto.deviceList.getStoredCrossSigningForUser(userId);
          if (crossSigningInfo && crossSigningInfo.getId() === _deviceId) {
            verifier(_keyId, DeviceInfo.fromStorage({
              keys: {
                [_keyId]: _deviceId
              }
            }, _deviceId), _keyInfo);
            verifiedDevices.push([_deviceId, _keyId, _deviceId]);
          } else {
            logger.warn("verification: Could not find device ".concat(_deviceId, " to verify"));
          }
        }
      }

      // if none of the keys could be verified, then error because the app
      // should be informed about that
      if (!verifiedDevices.length) {
        throw new Error("No devices could be verified");
      }
      logger.info("Verification completed! Marking devices verified: ", verifiedDevices);
      // TODO: There should probably be a batch version of this, otherwise it's going
      // to upload each signature in a separate API call which is silly because the
      // API supports as many signatures as you like.
      for (var [_deviceId2, _keyId2, key] of verifiedDevices) {
        yield _this3.baseApis.crypto.setDeviceVerification(userId, _deviceId2, true, null, null, {
          [_keyId2]: key
        });
      }

      // if one of the user's own devices is being marked as verified / unverified,
      // check the key backup status, since whether or not we use this depends on
      // whether it has a signature from a verified device
      if (userId == _this3.baseApis.credentials.userId) {
        yield _this3.baseApis.checkKeyBackup();
      }
    })();
  }
  get events() {
    return undefined;
  }

  /**
   * Get the details for an SAS verification, if one is in progress
   *
   * Returns `null`, unless this verifier is for a SAS-based verification and we are waiting for the user to confirm
   * the SAS matches.
   */
  getShowSasCallbacks() {
    return null;
  }

  /**
   * Get the details for reciprocating QR code verification, if one is in progress
   *
   * Returns `null`, unless this verifier is for reciprocating a QR-code-based verification (ie, the other user has
   * already scanned our QR code), and we are waiting for the user to confirm.
   */
  getReciprocateQrCodeCallbacks() {
    return null;
  }
}
//# sourceMappingURL=Base.js.map