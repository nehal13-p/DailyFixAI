{"version":3,"file":"olm.js","names":["logger","olmlib","DeviceInfo","DecryptionAlgorithm","EncryptionAlgorithm","registerAlgorithm","DecryptionFailureCode","DecryptionError","DeviceVerification","OlmEncryption","constructor","arguments","_defineProperty","ensureSession","roomMembers","prepPromise","sessionPrepared","Promise","resolve","crypto","downloadKeys","then","ensureOlmSessionsForUsers","finally","encryptMessage","room","eventType","content","_this","_asyncToGenerator","members","getEncryptionTargetMembers","users","map","u","userId","payloadFields","room_id","roomId","type","encryptedContent","algorithm","OLM_ALGORITHM","sender_key","olmDevice","deviceCurve25519Key","ciphertext","promises","devices","getStoredDevicesForUser","deviceInfo","key","getIdentityKey","verified","BLOCKED","push","encryptMessageForDevice","deviceId","all","OlmDecryption","decryptEvent","event","_this2","getWireContent","deviceKey","OLM_MISSING_CIPHERTEXT","OLM_NOT_INCLUDED_IN_RECIPIENTS","message","payloadString","decryptMessage","e","OLM_BAD_ENCRYPTED_MESSAGE","sender","err","payload","JSON","parse","recipient","OLM_BAD_RECIPIENT","recipient_keys","ed25519","deviceEd25519Key","OLM_BAD_RECIPIENT_KEY","intended","our_key","senderKeyUser","deviceList","getUserByIdentityKey","undefined","getSender","OLM_BAD_SENDER_CHECK_FAILED","OLM_BAD_SENDER","real_sender","OLM_FORWARDED_MESSAGE","reported_sender","getRoomId","OLM_BAD_ROOM","reported_room","claimedKeys","keys","clearEvent","senderCurve25519Key","claimedEd25519Key","theirDeviceIdentityKey","reallyDecryptMessage","myPromise","olmPrekeyPromise","catch","_this3","sessionIds","getSessionIdsForDevice","decryptionErrors","sessionId","body","log","foundSession","matchesSession","Error","length","stringify","res","createInboundSession","session_id"],"sources":["../../../src/crypto/algorithms/olm.ts"],"sourcesContent":["/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Defines m.olm encryption/decryption\n */\n\nimport type { IEventDecryptionResult } from \"../../@types/crypto.ts\";\nimport { logger } from \"../../logger.ts\";\nimport * as olmlib from \"../olmlib.ts\";\nimport { DeviceInfo } from \"../deviceinfo.ts\";\nimport { DecryptionAlgorithm, EncryptionAlgorithm, registerAlgorithm } from \"./base.ts\";\nimport { Room } from \"../../models/room.ts\";\nimport { IContent, MatrixEvent } from \"../../models/event.ts\";\nimport { IEncryptedContent, IOlmEncryptedContent } from \"../index.ts\";\nimport { IInboundSession } from \"../OlmDevice.ts\";\nimport { DecryptionFailureCode } from \"../../crypto-api/index.ts\";\nimport { DecryptionError } from \"../../common-crypto/CryptoBackend.ts\";\n\nconst DeviceVerification = DeviceInfo.DeviceVerification;\n\nexport interface IMessage {\n    type: number;\n    body: string;\n}\n\n/**\n * Olm encryption implementation\n *\n * @param params - parameters, as per {@link EncryptionAlgorithm}\n */\nclass OlmEncryption extends EncryptionAlgorithm {\n    private sessionPrepared = false;\n    private prepPromise: Promise<void> | null = null;\n\n    /**\n     * @internal\n\n     * @param roomMembers - list of currently-joined users in the room\n     * @returns Promise which resolves when setup is complete\n     */\n    private ensureSession(roomMembers: string[]): Promise<void> {\n        if (this.prepPromise) {\n            // prep already in progress\n            return this.prepPromise;\n        }\n\n        if (this.sessionPrepared) {\n            // prep already done\n            return Promise.resolve();\n        }\n\n        this.prepPromise = this.crypto\n            .downloadKeys(roomMembers)\n            .then(() => {\n                return this.crypto.ensureOlmSessionsForUsers(roomMembers);\n            })\n            .then(() => {\n                this.sessionPrepared = true;\n            })\n            .finally(() => {\n                this.prepPromise = null;\n            });\n\n        return this.prepPromise;\n    }\n\n    /**\n     * @param content - plaintext event content\n     *\n     * @returns Promise which resolves to the new event body\n     */\n    public async encryptMessage(room: Room, eventType: string, content: IContent): Promise<IOlmEncryptedContent> {\n        // pick the list of recipients based on the membership list.\n        //\n        // TODO: there is a race condition here! What if a new user turns up\n        // just as you are sending a secret message?\n\n        const members = await room.getEncryptionTargetMembers();\n\n        const users = members.map(function (u) {\n            return u.userId;\n        });\n\n        await this.ensureSession(users);\n\n        const payloadFields = {\n            room_id: room.roomId,\n            type: eventType,\n            content: content,\n        };\n\n        const encryptedContent: IEncryptedContent = {\n            algorithm: olmlib.OLM_ALGORITHM,\n            sender_key: this.olmDevice.deviceCurve25519Key!,\n            ciphertext: {},\n        };\n\n        const promises: Promise<void>[] = [];\n\n        for (const userId of users) {\n            const devices = this.crypto.getStoredDevicesForUser(userId) || [];\n\n            for (const deviceInfo of devices) {\n                const key = deviceInfo.getIdentityKey();\n                if (key == this.olmDevice.deviceCurve25519Key) {\n                    // don't bother sending to ourself\n                    continue;\n                }\n                if (deviceInfo.verified == DeviceVerification.BLOCKED) {\n                    // don't bother setting up sessions with blocked users\n                    continue;\n                }\n\n                promises.push(\n                    olmlib.encryptMessageForDevice(\n                        encryptedContent.ciphertext,\n                        this.userId,\n                        this.deviceId,\n                        this.olmDevice,\n                        userId,\n                        deviceInfo,\n                        payloadFields,\n                    ),\n                );\n            }\n        }\n\n        return Promise.all(promises).then(() => encryptedContent);\n    }\n}\n\n/**\n * Olm decryption implementation\n *\n * @param params - parameters, as per {@link DecryptionAlgorithm}\n */\nclass OlmDecryption extends DecryptionAlgorithm {\n    /**\n     * returns a promise which resolves to a\n     * {@link EventDecryptionResult} once we have finished\n     * decrypting. Rejects with an `algorithms.DecryptionError` if there is a\n     * problem decrypting the event.\n     */\n    public async decryptEvent(event: MatrixEvent): Promise<IEventDecryptionResult> {\n        const content = event.getWireContent();\n        const deviceKey = content.sender_key;\n        const ciphertext = content.ciphertext;\n\n        if (!ciphertext) {\n            throw new DecryptionError(DecryptionFailureCode.OLM_MISSING_CIPHERTEXT, \"Missing ciphertext\");\n        }\n\n        if (!(this.olmDevice.deviceCurve25519Key! in ciphertext)) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_NOT_INCLUDED_IN_RECIPIENTS,\n                \"Not included in recipients\",\n            );\n        }\n        const message = ciphertext[this.olmDevice.deviceCurve25519Key!];\n        let payloadString: string;\n\n        try {\n            payloadString = await this.decryptMessage(deviceKey, message);\n        } catch (e) {\n            throw new DecryptionError(DecryptionFailureCode.OLM_BAD_ENCRYPTED_MESSAGE, \"Bad Encrypted Message\", {\n                sender: deviceKey,\n                err: e as Error,\n            });\n        }\n\n        const payload = JSON.parse(payloadString);\n\n        // check that we were the intended recipient, to avoid unknown-key attack\n        // https://github.com/vector-im/vector-web/issues/2483\n        if (payload.recipient != this.userId) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_BAD_RECIPIENT,\n                \"Message was intended for \" + payload.recipient,\n            );\n        }\n\n        if (payload.recipient_keys.ed25519 != this.olmDevice.deviceEd25519Key) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_BAD_RECIPIENT_KEY,\n                \"Message not intended for this device\",\n                {\n                    intended: payload.recipient_keys.ed25519,\n                    our_key: this.olmDevice.deviceEd25519Key!,\n                },\n            );\n        }\n\n        // check that the device that encrypted the event belongs to the user that the event claims it's from.\n        //\n        // If the device is unknown then we check that we don't have any pending key-query requests for the sender. If\n        // after that the device is still unknown, then we can only assume that the device logged out and accept it\n        // anyway. Some event handlers, such as secret sharing, may be more strict and reject events that come from\n        // unknown devices.\n        //\n        // This is a defence against the following scenario:\n        //\n        //   * Alice has verified Bob and Mallory.\n        //   * Mallory gets control of Alice's server, and sends a megolm session to Alice using her (Mallory's)\n        //     senderkey, but claiming to be from Bob.\n        //   * Mallory sends more events using that session, claiming to be from Bob.\n        //   * Alice sees that the senderkey is verified (since she verified Mallory) so marks events those events as\n        //     verified even though the sender is forged.\n        //\n        // In practice, it's not clear that the js-sdk would behave that way, so this may be only a defence in depth.\n\n        let senderKeyUser = this.crypto.deviceList.getUserByIdentityKey(olmlib.OLM_ALGORITHM, deviceKey);\n        if (senderKeyUser === undefined || senderKeyUser === null) {\n            // Wait for any pending key query fetches for the user to complete before trying the lookup again.\n            try {\n                await this.crypto.deviceList.downloadKeys([event.getSender()!], false);\n            } catch (e) {\n                throw new DecryptionError(\n                    DecryptionFailureCode.OLM_BAD_SENDER_CHECK_FAILED,\n                    \"Could not verify sender identity\",\n                    {\n                        sender: deviceKey,\n                        err: e as Error,\n                    },\n                );\n            }\n\n            senderKeyUser = this.crypto.deviceList.getUserByIdentityKey(olmlib.OLM_ALGORITHM, deviceKey);\n        }\n        if (senderKeyUser !== event.getSender() && senderKeyUser !== undefined && senderKeyUser !== null) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_BAD_SENDER,\n                \"Message claimed to be from \" + event.getSender(),\n                {\n                    real_sender: senderKeyUser,\n                },\n            );\n        }\n\n        // check that the original sender matches what the homeserver told us, to\n        // avoid people masquerading as others.\n        // (this check is also provided via the sender's embedded ed25519 key,\n        // which is checked elsewhere).\n        if (payload.sender != event.getSender()) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_FORWARDED_MESSAGE,\n                \"Message forwarded from \" + payload.sender,\n                {\n                    reported_sender: event.getSender()!,\n                },\n            );\n        }\n\n        // Olm events intended for a room have a room_id.\n        if (payload.room_id !== event.getRoomId()) {\n            throw new DecryptionError(\n                DecryptionFailureCode.OLM_BAD_ROOM,\n                \"Message intended for room \" + payload.room_id,\n                {\n                    reported_room: event.getRoomId() || \"ROOM_ID_UNDEFINED\",\n                },\n            );\n        }\n\n        const claimedKeys = payload.keys || {};\n\n        return {\n            clearEvent: payload,\n            senderCurve25519Key: deviceKey,\n            claimedEd25519Key: claimedKeys.ed25519 || null,\n        };\n    }\n\n    /**\n     * Attempt to decrypt an Olm message\n     *\n     * @param theirDeviceIdentityKey -  Curve25519 identity key of the sender\n     * @param message -  message object, with 'type' and 'body' fields\n     *\n     * @returns payload, if decrypted successfully.\n     */\n    private decryptMessage(theirDeviceIdentityKey: string, message: IMessage): Promise<string> {\n        // This is a wrapper that serialises decryptions of prekey messages, because\n        // otherwise we race between deciding we have no active sessions for the message\n        // and creating a new one, which we can only do once because it removes the OTK.\n        if (message.type !== 0) {\n            // not a prekey message: we can safely just try & decrypt it\n            return this.reallyDecryptMessage(theirDeviceIdentityKey, message);\n        } else {\n            const myPromise = this.olmDevice.olmPrekeyPromise.then(() => {\n                return this.reallyDecryptMessage(theirDeviceIdentityKey, message);\n            });\n            // we want the error, but don't propagate it to the next decryption\n            this.olmDevice.olmPrekeyPromise = myPromise.catch(() => {});\n            return myPromise;\n        }\n    }\n\n    private async reallyDecryptMessage(theirDeviceIdentityKey: string, message: IMessage): Promise<string> {\n        const sessionIds = await this.olmDevice.getSessionIdsForDevice(theirDeviceIdentityKey);\n\n        // try each session in turn.\n        const decryptionErrors: Record<string, string> = {};\n        for (const sessionId of sessionIds) {\n            try {\n                const payload = await this.olmDevice.decryptMessage(\n                    theirDeviceIdentityKey,\n                    sessionId,\n                    message.type,\n                    message.body,\n                );\n                logger.log(\"Decrypted Olm message from \" + theirDeviceIdentityKey + \" with session \" + sessionId);\n                return payload;\n            } catch (e) {\n                const foundSession = await this.olmDevice.matchesSession(\n                    theirDeviceIdentityKey,\n                    sessionId,\n                    message.type,\n                    message.body,\n                );\n\n                if (foundSession) {\n                    // decryption failed, but it was a prekey message matching this\n                    // session, so it should have worked.\n                    throw new Error(\n                        \"Error decrypting prekey message with existing session id \" +\n                            sessionId +\n                            \": \" +\n                            (<Error>e).message,\n                    );\n                }\n\n                // otherwise it's probably a message for another session; carry on, but\n                // keep a record of the error\n                decryptionErrors[sessionId] = (<Error>e).message;\n            }\n        }\n\n        if (message.type !== 0) {\n            // not a prekey message, so it should have matched an existing session, but it\n            // didn't work.\n\n            if (sessionIds.length === 0) {\n                throw new Error(\"No existing sessions\");\n            }\n\n            throw new Error(\n                \"Error decrypting non-prekey message with existing sessions: \" + JSON.stringify(decryptionErrors),\n            );\n        }\n\n        // prekey message which doesn't match any existing sessions: make a new\n        // session.\n\n        let res: IInboundSession;\n        try {\n            res = await this.olmDevice.createInboundSession(theirDeviceIdentityKey, message.type, message.body);\n        } catch (e) {\n            decryptionErrors[\"(new)\"] = (<Error>e).message;\n            throw new Error(\"Error decrypting prekey message: \" + JSON.stringify(decryptionErrors));\n        }\n\n        logger.log(\"created new inbound Olm session ID \" + res.session_id + \" with \" + theirDeviceIdentityKey);\n        return res.payload;\n    }\n}\n\nregisterAlgorithm(olmlib.OLM_ALGORITHM, OlmEncryption, OlmDecryption);\n"],"mappings":"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","ignoreList":[]}