import { TypedEventEmitter } from "../models/typed-event-emitter.ts";
import { Room } from "../models/room.ts";
import { MatrixClient } from "../client.ts";
import { CallMembership } from "./CallMembership.ts";
import { Focus } from "./focus.ts";
import { MatrixEvent } from "../models/event.ts";
export declare enum MatrixRTCSessionEvent {
    MembershipsChanged = "memberships_changed",
    JoinStateChanged = "join_state_changed",
    EncryptionKeyChanged = "encryption_key_changed"
}
export type MatrixRTCSessionEventHandlerMap = {
    [MatrixRTCSessionEvent.MembershipsChanged]: (oldMemberships: CallMembership[], newMemberships: CallMembership[]) => void;
    [MatrixRTCSessionEvent.JoinStateChanged]: (isJoined: boolean) => void;
    [MatrixRTCSessionEvent.EncryptionKeyChanged]: (key: Uint8Array, encryptionKeyIndex: number, participantId: string) => void;
};
export interface JoinSessionConfig {
    /**
     *  If true, generate and share a media key for this participant,
     *  and emit MatrixRTCSessionEvent.EncryptionKeyChanged when
     *  media keys for other participants become available.
     */
    manageMediaKeys?: boolean;
    /** Lets you configure how the events for the session are formatted.
     *   - legacy: use one event with a membership array.
     *   - MSC4143: use one event per membership (with only one membership per event)
     * More details can be found in MSC4143 and by checking the types:
     * `CallMembershipDataLegacy` and `SessionMembershipData`
     */
    useLegacyMemberEvents?: boolean;
    /**
     * The timeout (in milliseconds) after we joined the call, that our membership should expire
     * unless we have explicitly updated it.
     */
    membershipExpiryTimeout?: number;
    /**
     * The period (in milliseconds) with which we check that our membership event still exists on the
     * server. If it is not found we create it again.
     */
    memberEventCheckPeriod?: number;
    /**
     * The minimum delay (in milliseconds) after which we will retry sending the membership event if it
     * failed to send.
     */
    callMemberEventRetryDelayMinimum?: number;
    /**
     * The jitter (in milliseconds) which is added to callMemberEventRetryDelayMinimum before retrying
     * sending the membership event. e.g. if this is set to 1000, then a random delay of between 0 and 1000
     * milliseconds will be added.
     */
    callMemberEventRetryJitter?: number;
    /**
     * The minimum time (in milliseconds) between each attempt to send encryption key(s).
     * e.g. if this is set to 1000, then we will send at most one key event every second.
     */
    updateEncryptionKeyThrottle?: number;
    /**
     * The delay (in milliseconds) after a member leaves before we create and publish a new key, because people
     * tend to leave calls at the same time.
     */
    makeKeyDelay?: number;
    /**
     * The delay (in milliseconds) between creating and sending a new key and starting to encrypt with it. This
     * gives other a chance to receive the new key to minimise the chance they don't get media they can't decrypt.
     * The total time between a member leaving and the call switching to new keys is therefore:
     * makeKeyDelay + useKeyDelay
     */
    useKeyDelay?: number;
    /**
     * The timeout (in milliseconds) after which the server will consider the membership to have expired if it
     * has not received a keep-alive from the client.
     */
    membershipServerSideExpiryTimeout?: number;
    /**
     * The period (in milliseconds) that the client will send membership keep-alives to the server.
     */
    membershipKeepAlivePeriod?: number;
}
/**
 * A MatrixRTCSession manages the membership & properties of a MatrixRTC session.
 * This class doesn't deal with media at all, just membership & properties of a session.
 */
export declare class MatrixRTCSession extends TypedEventEmitter<MatrixRTCSessionEvent, MatrixRTCSessionEventHandlerMap> {
    private readonly client;
    readonly room: Room;
    memberships: CallMembership[];
    private _callId;
    private relativeExpiry;
    private joinConfig?;
    private get membershipExpiryTimeout();
    private get memberEventCheckPeriod();
    private get callMemberEventRetryDelayMinimum();
    private get updateEncryptionKeyThrottle();
    private get makeKeyDelay();
    private get useKeyDelay();
    /**
     * If the server disallows the configured {@link membershipServerSideExpiryTimeout},
     * this stores a delay that the server does allow.
     */
    private membershipServerSideExpiryTimeoutOverride?;
    private get membershipServerSideExpiryTimeout();
    private get membershipKeepAlivePeriod();
    private get callMemberEventRetryJitter();
    private membershipId;
    private memberEventTimeout?;
    private expiryTimeout?;
    private keysEventUpdateTimeout?;
    private makeNewKeyTimeout?;
    private setNewKeyTimeouts;
    private ownFocusActive?;
    private ownFociPreferred?;
    private updateCallMembershipRunning;
    private needCallMembershipUpdate;
    private manageMediaKeys;
    private useLegacyMemberEvents;
    private encryptionKeys;
    private lastEncryptionKeyUpdateRequest?;
    private disconnectDelayId;
    private lastMembershipFingerprints;
    private currentEncryptionKeyIndex;
    /**
     * The statistics for this session.
     */
    statistics: {
        counters: {
            /**
             * The number of times we have sent a room event containing encryption keys.
             */
            roomEventEncryptionKeysSent: number;
            /**
             * The number of times we have received a room event containing encryption keys.
             */
            roomEventEncryptionKeysReceived: number;
        };
        totals: {
            /**
             * The total age (in milliseconds) of all room events containing encryption keys that we have received.
             * We track the total age so that we can later calculate the average age of all keys received.
             */
            roomEventEncryptionKeysReceivedTotalAge: number;
        };
    };
    /**
     * The callId (sessionId) of the call.
     *
     * It can be undefined since the callId is only known once the first membership joins.
     * The callId is the property that, per definition, groups memberships into one call.
     */
    get callId(): string | undefined;
    /**
     * Returns all the call memberships for a room, oldest first
     */
    static callMembershipsForRoom(room: Room): CallMembership[];
    /**
     * Return the MatrixRTC session for the room, whether there are currently active members or not
     */
    static roomSessionForRoom(client: MatrixClient, room: Room): MatrixRTCSession;
    private constructor();
    isJoined(): boolean;
    /**
     * Performs cleanup & removes timers for client shutdown
     */
    stop(): Promise<void>;
    /**
     * Announces this user and device as joined to the MatrixRTC session,
     * and continues to update the membership event to keep it valid until
     * leaveRoomSession() is called
     * This will not subscribe to updates: remember to call subscribe() separately if
     * desired.
     * This method will return immediately and the session will be joined in the background.
     *
     * @param fociActive - The object representing the active focus. (This depends on the focus type.)
     * @param fociPreferred - The list of preferred foci this member proposes to use/knows/has access to.
     *                        For the livekit case this is a list of foci generated from the homeserver well-known, the current rtc session,
     *                        or optionally other room members homeserver well known.
     * @param joinConfig - Additional configuration for the joined session.
     */
    joinRoomSession(fociPreferred: Focus[], fociActive?: Focus, joinConfig?: JoinSessionConfig): void;
    /**
     * Announces this user and device as having left the MatrixRTC session
     * and stops scheduled updates.
     * This will not unsubscribe from updates: remember to call unsubscribe() separately if
     * desired.
     * The membership update required to leave the session will retry if it fails.
     * Without network connection the promise will never resolve.
     * A timeout can be provided so that there is a guarantee for the promise to resolve.
     * @returns Whether the membership update was attempted and did not time out.
     */
    leaveRoomSession(timeout?: number | undefined): Promise<boolean>;
    getActiveFocus(): Focus | undefined;
    /**
     * Re-emit an EncryptionKeyChanged event for each tracked encryption key. This can be used to export
     * the keys.
     */
    reemitEncryptionKeys(): void;
    /**
     * Get the known encryption keys for a given participant device.
     *
     * @param userId the user ID of the participant
     * @param deviceId the device ID of the participant
     * @returns The encryption keys for the given participant, or undefined if they are not known.
     *
     * @deprecated This will be made private in a future release.
     */
    getKeysForParticipant(userId: string, deviceId: string): Array<Uint8Array> | undefined;
    private getKeysForParticipantInternal;
    /**
     * A map of keys used to encrypt and decrypt (we are using a symmetric
     * cipher) given participant's media. This also includes our own key
     *
     * @deprecated This will be made private in a future release.
     */
    getEncryptionKeys(): IterableIterator<[string, Array<Uint8Array>]>;
    private getNewEncryptionKeyIndex;
    /**
     * Sets an encryption key at a specified index for a participant.
     * The encryption keys for the local participant are also stored here under the
     * user and device ID of the local participant.
     * If the key is older than the existing key at the index, it will be ignored.
     * @param userId - The user ID of the participant
     * @param deviceId - Device ID of the participant
     * @param encryptionKeyIndex - The index of the key to set
     * @param encryptionKeyString - The string representation of the key to set in base64
     * @param timestamp - The timestamp of the key. We assume that these are monotonic for each participant device.
     * @param delayBeforeUse - If true, delay before emitting a key changed event. Useful when setting
     *                         encryption keys for the local participant to allow time for the key to
     *                         be distributed.
     */
    private setEncryptionKey;
    /**
     * Generate a new sender key and add it at the next available index
     * @param delayBeforeUse - If true, wait for a short period before setting the key for the
     *                         media encryptor to use. If false, set the key immediately.
     * @returns The index of the new key
     */
    private makeNewSenderKey;
    /**
     * Requests that we resend our current keys to the room. May send a keys event immediately
     * or queue for alter if one has already been sent recently.
     */
    private requestSendCurrentKey;
    /**
     * Re-sends the encryption keys room event
     */
    private sendEncryptionKeysEvent;
    /**
     * Sets a timer for the soonest membership expiry
     */
    private setExpiryTimer;
    getOldestMembership(): CallMembership | undefined;
    getFocusInUse(): Focus | undefined;
    /**
     * Process `m.call.encryption_keys` events to track the encryption keys for call participants.
     * This should be called each time the relevant event is received from a room timeline.
     * If the event is malformed then it will be logged and ignored.
     *
     * @param event the event to process
     */
    onCallEncryption: (event: MatrixEvent) => void;
    private isMyMembership;
    /**
     * Examines the latest call memberships and handles any encryption key sending or rotation that is needed.
     *
     * This function should be called when the room members or call memberships might have changed.
     */
    onMembershipUpdate: () => void;
    private storeLastMembershipFingerprints;
    /**
     * Constructs our own membership
     * @param prevMembership - The previous value of our call membership, if any
     */
    private makeMyMembershipLegacy;
    /**
     * Constructs our own membership
     */
    private makeMyMembership;
    /**
     * Returns true if our membership event needs to be updated
     */
    private membershipEventNeedsUpdate;
    private makeNewMembership;
    /**
     * Makes a new membership list given the old list along with this user's previous membership event
     * (if any) and this device's previous membership (if any)
     */
    private makeNewLegacyMemberships;
    private triggerCallMembershipEventUpdate;
    private updateCallMembershipEvent;
    private scheduleDelayDisconnection;
    private readonly delayDisconnection;
    private stateEventsContainOngoingLegacySession;
    private makeMembershipStateKey;
    private onRotateKeyTimeout;
}
//# sourceMappingURL=MatrixRTCSession.d.ts.map